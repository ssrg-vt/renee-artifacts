(lem_set_aux
 (empty_0 0
  (empty_0-1 nil 3743265491 ("" (grind) nil nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (empty_1 0
  (empty_1-1 nil 3743265496 ("" (grind) nil nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (empty_2 0
  (empty_2-1 nil 3743265499 ("" (grind) nil nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (empty_3 0
  (empty_3-1 nil 3743265502 ("" (grind) nil nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (any_0 0
  (any_0-1 nil 3743265507
   ("" (grind) (("" (inst 1 "6") (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (some const-decl "bool" sets nil))
   shostak))
 (any_1 0
  (any_1-1 nil 3743265580 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (some const-decl "bool" sets nil))
   shostak))
 (all_0 0
  (all_0-1 nil 3743265586 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (every const-decl "bool" sets nil))
   shostak))
 (all_1 0
  (all_1-1 nil 3743265590
   ("" (grind) (("" (inst -1 "1") (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (every const-decl "bool" sets nil))
   shostak))
 (inmem_1 0
  (inmem_1-1 nil 3743265612 ("" (grind) nil nil)
   ((extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (member const-decl "bool" set_extra nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (inmem_2 0
  (inmem_2-1 nil 3743265616 ("" (grind) nil nil)
   ((extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (member const-decl "bool" set_extra nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (inmem_3 0
  (inmem_3-1 nil 3743265619 ("" (grind) nil nil)
   ((emptyset const-decl "set" sets nil)
    (extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (member const-decl "bool" set_extra nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_extend application-judgement "finite_set[T]"
     extend_set_props nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (inmem_4 0
  (inmem_4-1 nil 3743265621 ("" (grind) nil nil)
   ((extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (member const-decl "bool" set_extra nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (nin_1 0
  (nin_1-1 nil 3743265624 ("" (grind) nil nil)
   ((extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (member const-decl "bool" set_extra nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (nin_2 0
  (nin_2-1 nil 3743265627 ("" (grind) nil nil)
   ((extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (member const-decl "bool" set_extra nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (nin_3 0
  (nin_3-1 nil 3743265630 ("" (grind) nil nil)
   ((emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (member const-decl "bool" set_extra nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (nin_4 0
  (nin_4-1 nil 3743265633 ("" (grind) nil nil)
   ((extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (member const-decl "bool" set_extra nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (null_1 0
  (null_1-1 nil 3743265635 ("" (grind) nil nil)
   ((emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (null_2 0
  (null_2-1 nil 3743265641 ("" (grind) nil nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil))
   shostak))
 (singleton_1_TCC1 0
  (singleton_1_TCC1-1 nil 3743265456
   ("" (grind) (("" (inst 1 "2") (("" (grind) nil nil)) nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FALSE const-decl "bool" booleans nil)
    (extend const-decl "R" extend nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton? const-decl "bool" sets nil))
   nil
   (singleton_1 subtype
    "extend[real, nat, booleans.boolean, booleans.FALSE].extend({x0: naturalnumbers.nat | x0 = (2)})"
    "(sets[real].singleton?)")))
 (singleton_1 0
  (singleton_1-1 nil 3743265646
   ("" (grind)
    (("" (expand "extend")
      (("" (expand "singleton")
        (("" (assert)
          (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((extend const-decl "R" extend nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (FALSE const-decl "bool" booleans nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" set_as_list "structures/")
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (singleton_2 0
  (singleton_2-1 nil 3743265813
   ("" (expand "singleton") (("" (grind) nil nil)) nil)
   ((empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (singleton const-decl "(singleton?)" sets nil))
   shostak))
 (singleton_3 0
  (singleton_3-1 nil 3743265829
   ("" (expand "singleton") (("" (grind) nil nil)) nil)
   ((member const-decl "bool" set_extra nil)
    (member const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil))
   shostak))
 (singleton_4 0
  (singleton_4-1 nil 3743265874
   ("" (expand "singleton") (("" (grind) nil nil)) nil)
   ((member const-decl "bool" set_extra nil)
    (member const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil))
   shostak))
 (size_1_TCC1 0
  (size_1_TCC1-1 nil 3743266053 ("" (subtype-tcc) nil nil) nil nil
   (size_1 subtype "(0)"
    "{n: naturalnumbers.nat | n = finite_sets[nat].Card(sets[nat].emptyset)}")))
 (size_1 0
  (size_1-1 nil 3743265884
   ("" (grind)
    (("" (use "empty_card" ("S" "emptyset[nat]"))
      (("" (grind) nil nil)) nil))
    nil)
   ((empty_card formula-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (size_2_TCC1 0
  (size_2_TCC1-1 nil 3743266053 ("" (subtype-tcc) nil nil) nil nil
   (size_2 subtype "(1)"
    "{n: naturalnumbers.nat | n = finite_sets[nat].Card({x0: naturalnumbers.nat | x0 = (2)})}")))
 (size_2_TCC2 0
  (size_2_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil
   (size_2 subtype "{x0: naturalnumbers.nat | x0 = (2)}"
    "finite_set[nat]")))
 (size_2 0
  (size_2-1 nil 3743266199
   ("" (grind)
    (("" (use "card_one" ("S" "{x0: nat | x0 = (2)}"))
      (("1" (grind)
        (("1" (hide 1)
          (("1" (expand "singleton") (("1" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (grind) (("2" (inst 1 "pred") (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (TRUE const-decl "bool" booleans nil)
    (card_one formula-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" set_as_list "structures/")
    (pred const-decl "nat" naturalnumbers nil)
    (restrict const-decl "R" restrict nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (size_3_TCC1 0
  (size_3_TCC1-1 nil 3743266053 ("" (subtype-tcc) nil nil) nil nil
   (size_3 subtype "(1)"
    "{n: naturalnumbers.nat | n = finite_sets[nat].Card({x0: naturalnumbers.nat | booleans.OR(x0 = (1), x0 = (1))})}")))
 (size_3_TCC2 0
  (size_3_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil
   (size_3 subtype
    "{x0: naturalnumbers.nat | booleans.OR(x0 = (1), x0 = (1))}"
    "finite_set[nat]")))
 (size_3 0
  (size_3-1 nil 3743349838
   ("" (grind)
    (("" (use "card_one" ("S" "{x0: nat | x0 = (1) OR x0 = (1)}"))
      (("1" (grind)
        (("1" (hide 1)
          (("1" (expand "singleton")
            (("1" (decompose-equality) (("1" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2"
        (inst 1 "1"
         "LAMBDA (x: {x0: nat | x0 = (1) OR x0 = (1)}): x - 1")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (card_one formula-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" set_as_list "structures/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (size_4_TCC1 0
  (size_4_TCC1-1 nil 3743266053 ("" (subtype-tcc) nil nil) nil nil
   (size_4 subtype "(3)"
    "{n: naturalnumbers.nat | n = finite_sets[nat].Card({x0: naturalnumbers.nat | booleans.OR(x0 = (2), booleans.OR(x0 = (1), x0 = (3)))})}")))
 (size_4_TCC2 0
  (size_4_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil
   (size_4 subtype
    "{x0: naturalnumbers.nat | booleans.OR(x0 = (2), booleans.OR(x0 = (1), x0 = (3)))}"
    "finite_set[nat]")))
 (size_4 0
  (size_4-1 nil 3743266412
   (""
    (use "card_bij"
         ("S" "{x0: nat | x0 = (2) OR x0 = (1) OR x0 = (3)}" "N" "3"))
    (("1" (prop)
      (("1" (replace -1) (("1" (grind) nil nil)) nil)
       ("2" (inst 1 "pred")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("2" (expand "is_finite")
      (("2" (inst 1 "3" "pred")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((eqs const-decl "bool" lib_extra nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (y!1 skolem-const-decl "below[3]" lem_set_aux nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (restrict const-decl "R" restrict nil)
    (below type-eq-decl nil nat_types nil)
    (pred const-decl "nat" naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (card_bij formula-decl nil finite_sets nil))
   shostak))
 (size_5_TCC1 0
  (size_5_TCC1-1 nil 3743266053 ("" (subtype-tcc) nil nil) nil nil
   (size_5 subtype "(4)"
    "{n: naturalnumbers.nat | n = finite_sets[nat].Card({x0: naturalnumbers.nat | booleans.OR(x0 = (2), booleans.OR(x0 = (1), booleans.OR(x0 = (3), x0 = (9))))})}")))
 (size_5_TCC2 0
  (size_5_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil
   (size_5 subtype
    "{x0: naturalnumbers.nat | booleans.OR(x0 = (2), booleans.OR(x0 = (1), booleans.OR(x0 = (3), x0 = (9))))}"
    "finite_set[nat]")))
 (size_5 0
  (size_5-1 nil 3743266629
   ("" (grind)
    ((""
      (use "card_bij"
           ("S"
            "{x0: nat | x0 = (2) OR x0 = (1) OR x0 = (3) OR x0 = (9)}"
            "N" "4"))
      (("1" (grind)
        (("1" (hide 1)
          (("1"
            (inst 1 "LAMBDA (x: {x0: nat |
                     x0 = (2) OR x0 = (1) OR x0 = (3) OR x0 = (9)}): mod(x, 9)")
            (("1" (prop)
              (("1" (grind) nil nil)
               ("2" (skeep)
                (("2" (typepred "y")
                  (("2" (case "y = 0")
                    (("1" (inst 1 "9") (("1" (grind) nil nil)) nil)
                     ("2" (case "y = 1")
                      (("1" (inst 2 "1") (("1" (grind) nil nil)) nil)
                       ("2" (case "y = 2")
                        (("1" (inst 3 "2") (("1" (grind) nil nil)) nil)
                         ("2" (case "y = 3")
                          (("1" (inst 4 "3") (("1" (grind) nil nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2"
        (inst 1 "4" "LAMBDA (x: {x0: nat |
                     x0 = (2) OR x0 = (1) OR x0 = (3) OR x0 = (9)}): mod(x, 9)")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (card_bij formula-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mod const-decl "{k | abs(k) < abs(j)}" mod nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nonzero_integer nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (nil application-judgement "below(m)" mod nil)
    (surjective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (null_size_TCC1 0
  (null_size_TCC1-1 nil 3743266053 ("" (subtype-tcc) nil nil) nil nil
   (null_size subtype "(0)"
    "{n: naturalnumbers.nat | n = finite_sets[lem_set_aux.A].Card(lem_set_aux.s)}")))
 (null_size_TCC2 0
  (null_size_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil
   (null_size subtype "lem_set_aux.s" "finite_set[A]")))
 (null_size_TCC3 0
  (null_size_TCC3-1 nil 3743266053 ("" (subtype-tcc) nil nil) nil nil
   (null_size subtype "lem_set_aux.s" "finite_set[A]")))
 (null_size 0
  (null_size-1 nil 3743267667
   ("" (grind)
    (("" (use "empty_card" ("S" "s!1")) (("" (grind) nil nil)) nil))
    nil)
   ((empty_card formula-decl nil finite_sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (A decl-formal-type nil lem_set_aux nil)
    (bool_or const-decl "bool" lib_extra nil)
    (eqs const-decl "bool" lib_extra nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   shostak))
 (null_singleton_TCC1 0
  (null_singleton_TCC1-1 nil 3743266053 ("" (subtype-tcc) nil nil) nil
   nil
   (null_singleton subtype "(1)"
    "{n: naturalnumbers.nat | n = finite_sets[lem_set_aux.A].Card(sets[lem_set_aux.A].singleton(lem_set_aux.x))}")))
 (null_singleton 0
  (null_singleton-1 nil 3743267705
   ("" (grind)
    (("" (use "card_one" ("S" "singleton(x!1)")) (("" (grind) nil nil))
      nil))
    nil)
   ((card_one formula-decl nil finite_sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (A decl-formal-type nil lem_set_aux nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" set_as_list "structures/")
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (set_patterns_0 0
  (set_patterns_0-1 nil 3743267745 ("" (grind) nil nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (set_case const-decl "A" set_extra nil))
   shostak))
 (set_patterns_1 0
  (set_patterns_1-1 nil 3743267752
   ("" (grind)
    (("" (expand "emptyset")
      (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((emptyset const-decl "set" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (set_case const-decl "A" set_extra nil))
   shostak))
 (set_patterns_2_TCC1 0
  (set_patterns_2_TCC1-1 nil 3743265456
   ("" (subtype-tcc)
    ((""
      (inst 1 "2"
       "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (4)}): x - 3")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil))
   nil
   (set_patterns_2 subtype
    "{x0: naturalnumbers.nat | booleans.OR(x0 = (3), x0 = (4))}"
    "finite_set[nat]")))
 (set_patterns_2 0
  (set_patterns_2-1 nil 3743267777
   ("" (grind)
    (("" (expand "emptyset")
      (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((emptyset const-decl "set" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (set_case const-decl "A" set_extra nil))
   shostak))
 (set_patterns_3 0
  (set_patterns_3-1 nil 3743267791
   ("" (grind)
    (("1" (expand "emptyset")
      (("1" (decompose-equality) (("1" (grind) nil nil)) nil)) nil)
     ("2" (use "card_one" ("S" "{x0: nat | x0 = (2)}"))
      (("1" (prop)
        (("1" (inst 1 "2")
          (("1" (grind)
            (("1" (expand "singleton") (("1" (propax) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (inst 1 "1" "LAMBDA (x:nat): mod(x, 1)") nil nil))
      nil))
    nil)
   ((injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (TRUE const-decl "bool" booleans nil)
    (card_one formula-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" set_as_list "structures/")
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (restrict const-decl "R" restrict nil)
    (/= const-decl "boolean" notequal nil)
    (nonzero_integer nonempty-type-eq-decl nil integers nil)
    (mod const-decl "{k | abs(k) < abs(j)}" mod nil)
    (nil application-judgement "below(m)" mod nil)
    (emptyset const-decl "set" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (eqs const-decl "bool" lib_extra nil)
    (set_case const-decl "A" set_extra nil))
   shostak))
 (set_patterns_4 0
  (set_patterns_4-1 nil 3743268458 ("" (grind) nil nil)
   ((set_case const-decl "A" set_extra nil)
    (eqs const-decl "bool" lib_extra nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (set_patterns_5_TCC1 0
  (set_patterns_5_TCC1-1 nil 3743265456
   ("" (subtype-tcc)
    ((""
      (inst 1 "3"
       "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): x - 3")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil))
   nil
   (set_patterns_5 subtype
    "{x0: naturalnumbers.nat | booleans.OR(x0 = (3), booleans.OR(x0 = (4), x0 = (5)))}"
    "finite_set[nat]")))
 (set_patterns_5 0
  (set_patterns_5-1 nil 3743268469
   ("" (grind)
    (("1" (expand "emptyset")
      (("1" (decompose-equality) (("1" (grind) nil nil)) nil)) nil)
     ("2"
      (case "card({x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}) = 3")
      (("1" (grind) nil nil)
       ("2" (hide -1 2)
        (("2"
          (use "card_bij"
               ("S" "{x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}" "N"
                "3"))
          (("1" (grind)
            (("1"
              (inst 2
               "LAMBDA (x:{x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): mod(x, 3)")
              (("1" (hide 1)
                (("1" (prop)
                  (("1" (grind) nil nil)
                   ("2" (skeep)
                    (("2" (typepred "y")
                      (("2" (case "y = 0")
                        (("1" (inst 1 "3") (("1" (grind) nil nil)) nil)
                         ("2" (case "y = 1")
                          (("1" (inst 2 "4") (("1" (grind) nil nil))
                            nil)
                           ("2" (case "y = 2")
                            (("1" (inst 3 "5") (("1" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2"
            (inst 1 "3"
             "LAMBDA (x:{x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): mod(x, 3)")
            (("2" (grind) nil nil)) nil))
          nil))
        nil)
       ("3"
        (inst 1 "3"
         "LAMBDA (x:{x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): mod(x, 3)")
        (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (injective? const-decl "bool" functions nil)
    (card_bij formula-decl nil finite_sets nil)
    (nil application-judgement "below(m)" mod nil)
    (mod const-decl "{k | abs(k) < abs(j)}" mod nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nonzero_integer nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (surjective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil)
    (emptyset const-decl "set" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (eqs const-decl "bool" lib_extra nil)
    (set_case const-decl "A" set_extra nil))
   shostak))
 (set_patterns_6_TCC1 0
  (set_patterns_6_TCC1-1 nil 3743265456
   ("" (grind)
    ((""
      (inst 1 "1"
       "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (3) OR x0 = (3)}): x - 3")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil))
   nil
   (set_patterns_6 subtype
    "{x0: naturalnumbers.nat | booleans.OR(x0 = (3), booleans.OR(x0 = (3), x0 = (3)))}"
    "finite_set[nat]")))
 (set_patterns_6 0
  (set_patterns_6-1 nil 3743269567
   ("" (grind)
    (("1" (expand "emptyset")
      (("1" (decompose-equality) (("1" (grind) nil nil)) nil)) nil)
     ("2" (use "choose_singleton" ("x" "3"))
      (("2"
        (case "{x0: nat | x0 = (3) OR x0 = (3) OR x0 = (3)} = singleton(3)")
        (("1" (replaces -1)
          (("1" (grind)
            (("1" (replaces -1)
              (("1" (expand "restrict")
                (("1" (expand "singleton") (("1" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "singleton")
          (("2" (decompose-equality) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("3"
      (use "card_one"
           ("S" "{x0: nat | x0 = (3) OR x0 = (3) OR x0 = (3)}"))
      (("1" (grind)
        (("1" (hide 1)
          (("1" (expand "singleton")
            (("1" (decompose-equality) (("1" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2"
        (inst 1 "1"
         "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (3) OR x0 = (3)}): x - 3")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (card_one formula-decl nil finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (choose_singleton formula-decl nil sets_lemmas nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" set_as_list "structures/")
    (finite_restrict application-judgement "finite_set[S]"
     restrict_set_props nil)
    (restrict const-decl "R" restrict nil)
    (set type-eq-decl nil sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (eqs const-decl "bool" lib_extra nil)
    (set_case const-decl "A" set_extra nil))
   shostak))
 (set_patterns_7_TCC1 0
  (set_patterns_7_TCC1-1 nil 3743265456
   ("" (grind)
    ((""
      (inst 1
       "LAMBDA (x: {x1: nat | x1 = (3) OR x1 = (4) OR x1 = (5)}): x - 3")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s!1 skolem-const-decl "[nat -> boolean]" lem_set_aux nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil))
   nil (set_patterns_7 subtype "lem_set_aux.s" "finite_set[nat]")))
 (set_patterns_7 0
  (set_patterns_7-1 nil 3743270939
   ("" (grind)
    (("1" (expand "emptyset")
      (("1" (decompose-equality) (("1" (grind) nil nil)) nil)) nil)
     ("2"
      (case "card({x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}) = 3")
      (("1" (grind) nil nil)
       ("2"
        (use "card_bij"
             ("S" "{x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}"))
        (("1" (grind)
          (("1" (hide 1)
            (("1"
              (inst 1
               "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): x - 3")
              (("1" (prop)
                (("1" (grind) nil nil)
                 ("2" (skeep)
                  (("2" (typepred "y")
                    (("2" (case "y = 0")
                      (("1" (inst 1 "3") (("1" (grind) nil nil)) nil)
                       ("2" (case "y = 1")
                        (("1" (inst 2 "4") (("1" (grind) nil nil)) nil)
                         ("2" (case "y = 2")
                          (("1" (inst 3 "5") (("1" (grind) nil nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil)
         ("2"
          (inst 1 "3"
           "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): x - 3")
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil)
       ("3"
        (inst 1 "3"
         "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): x - 3")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("3"
      (use "card_bij"
           ("S" "{x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}"))
      (("1" (grind)
        (("1"
          (inst 2
           "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): x - 3")
          (("1" (hide 1) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil)
       ("2"
        (inst 1 "3"
         "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): x - 3")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (y!1 skolem-const-decl "below[3]" lem_set_aux nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (card_bij formula-decl nil finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (emptyset const-decl "set" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (eqs const-decl "bool" lib_extra nil)
    (set_case const-decl "A" set_extra nil))
   shostak))
 (set_patterns_8 0
  (set_patterns_8-1 nil 3743271799
   ("" (grind)
    ((""
      (case "card({x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}) = 3")
      (("1" (grind) nil nil)
       ("2" (hide -1 2)
        (("2"
          (use "card_bij"
               ("S" "{x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}"))
          (("1" (grind)
            (("1"
              (inst 2
               "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): x - 3")
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil)
           ("2"
            (inst 1 "3"
             "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): x - 3")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil)
       ("3"
        (inst 1 "3"
         "LAMBDA (x: {x0: nat | x0 = (3) OR x0 = (4) OR x0 = (5)}): x - 3")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((OR const-decl "[bool, bool -> bool]" booleans nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (injective? const-decl "bool" functions nil)
    (card_bij formula-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (y!1 skolem-const-decl "below[3]" lem_set_aux nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (surjective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (eqs const-decl "bool" lib_extra nil)
    (set_case const-decl "A" set_extra nil))
   shostak))
 (set_patterns_9_TCC1 0
  (set_patterns_9_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (eqs const-decl "bool" lib_extra nil))
   nil (set_patterns_9 subtype "num_extra.r" "nat")))
 (set_patterns_9_TCC2 0
  (set_patterns_9_TCC2-1 nil 3743265456
   ("" (grind)
    (("" (inst 1 "1" "LAMBDA (x: {x0: nat | x0 = (5)}): x - 5") nil
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil))
   nil
   (set_patterns_9 subtype "{x0: naturalnumbers.nat | x0 = (5)}"
    "finite_set[nat]")))
 (set_patterns_9 0
  (set_patterns_9-1 nil 3743271878
   ("" (grind)
    (("1" (expand "emptyset")
      (("1" (decompose-equality) (("1" (grind) nil nil)) nil)) nil)
     ("2" (use "card_one" ("S" "{x0: nat | x0 = (5)}"))
      (("1" (grind)
        (("1" (expand "singleton") (("1" (propax) nil nil)) nil)) nil)
       ("2" (inst 1 "1" "LAMBDA (x: {x0: nat | x0 = (5)}): x - 5") nil
        nil))
      nil))
    nil)
   ((injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (TRUE const-decl "bool" booleans nil)
    (card_one formula-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" set_as_list "structures/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (emptyset const-decl "set" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (eqs const-decl "bool" lib_extra nil)
    (set_case const-decl "A" set_extra nil))
   shostak))
 (set_patterns_10 0
  (set_patterns_10-1 nil 3743271967
   ("" (grind)
    (("" (hide 1)
      (("" (use "card_one" ("S" "{x0: nat | x0 = (2)}"))
        (("1" (grind)
          (("1" (expand "singleton") (("1" (propax) nil nil)) nil))
          nil)
         ("2" (inst 1 "1" "LAMBDA (x: {x0: nat | x0 = (2)}): x - 2")
          nil nil))
        nil))
      nil))
    nil)
   ((- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" set_as_list "structures/")
    (singleton const-decl "(singleton?)" sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (card_one formula-decl nil finite_sets nil)
    (TRUE const-decl "bool" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (eqs const-decl "bool" lib_extra nil)
    (set_case const-decl "A" set_extra nil))
   shostak))
 (union_1 0
  (union_1-1 nil 3743272021
   ("" (grind)
    (("" (expand "union")
      (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((union const-decl "set" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (eqs const-decl "bool" lib_extra nil)
    (union const-decl "set[A]" set_extra nil))
   shostak))
 (union_in 0
  (union_in-1 nil 3743272066 ("" (grind) nil nil)
   ((union const-decl "set[A]" set_extra nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" set_extra nil)
    (bool_or const-decl "bool" lib_extra nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (insert_1 0
  (insert_1-1 nil 3743272073
   ("" (grind)
    (("" (expand "extend")
      (("" (expand "add")
        (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((extend const-decl "R" extend nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (FALSE const-decl "bool" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (add const-decl "(nonempty?)" sets nil)
    (eqs const-decl "bool" lib_extra nil)
    (add const-decl "set[A]" set_extra nil))
   shostak))
 (insert_2 0
  (insert_2-1 nil 3743272096
   ("" (expand "add")
    (("" (expand "extend")
      (("" (expand "add")
        (("" (grind)
          (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((extend const-decl "R" extend nil)
    (eqs const-decl "bool" lib_extra nil)
    (member const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (FALSE const-decl "bool" booleans nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (add const-decl "set[A]" set_extra nil))
   shostak))
 (insert_3 0
  (insert_3-1 nil 3743272120
   ("" (grind)
    (("" (expand "extend")
      (("" (expand "add")
        (("" (expand "emptyset")
          (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((extend const-decl "R" extend nil)
    (emptyset const-decl "set" sets nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (FALSE const-decl "bool" booleans nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[T]" set_as_list "structures/")
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (add const-decl "set[A]" set_extra nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (filter_def_lemma_TCC1 0
  (filter_def_lemma_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil)
   nil nil (filter_def_lemma subtype "lem_set_aux.s" "finite_set[A]")))
 (filter_def_lemma_TCC2 0
  (filter_def_lemma_TCC2-1 nil 3743265456 ("" (subtype-tcc) nil nil)
   nil nil (filter_def_lemma subtype "lem_set_aux.s" "finite_set[A]")))
 (filter_def_lemma 0
  (filter_def_lemma-1 nil 3743272181 ("" (grind) nil nil)
   ((add const-decl "set[A]" set_extra nil)
    (filter const-decl "set[A]" set_extra nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (filter_1_TCC1 0
  (filter_1_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil
   (filter_1 subtype
    "{x0: naturalnumbers.nat | booleans.OR(x0 = (1), booleans.OR(x0 = (2), booleans.OR(x0 = (3), x0 = (4))))}"
    "finite_set[nat]")))
 (filter_1 0
  (filter_1-1 nil 3743272189
   ("" (grind)
    (("" (expand "filter")
      (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((filter const-decl "set[A]" set_extra nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (filter_2 0
  (filter_2-1 nil 3743354171
   ("" (grind)
    (("" (expand "filter")
      (("" (expand "emptyset") (("" (decompose-equality) nil nil))
        nil))
      nil))
    nil)
   ((filter const-decl "set[A]" set_extra nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (> const-decl "bool" reals nil)
    (FALSE const-decl "bool" booleans nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (filter_emp 0
  (filter_emp-1 nil 3743354178
   ("" (grind)
    (("" (expand "filter")
      (("" (expand "emptyset") (("" (decompose-equality) nil nil))
        nil))
      nil))
    nil)
   ((filter const-decl "set[A]" set_extra nil)
    (A decl-formal-type nil lem_set_aux nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (filter_insert_TCC1 0
  (filter_insert_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil (filter_insert subtype "lem_set_aux.s" "finite_set[A]")))
 (filter_insert_TCC2 0
  (filter_insert_TCC2-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil (filter_insert subtype "lem_set_aux.s" "finite_set[A]")))
 (filter_insert_TCC3 0
  (filter_insert_TCC3-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil
   (filter_insert subtype "set_extra.add(lem_set_aux.e)(lem_set_aux.s)"
    "finite_set[A]")))
 (filter_insert 0
  (filter_insert-1 nil 3743355857
   ("" (grind) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)
   nil shostak))
 (split_simple_TCC1 0
  (split_simple_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil
   (split_simple subtype
    "{x0: [naturalnumbers.nat, naturalnumbers.nat] |      (x0 = ((1), (0))) OR (x0 = ((2), (0))) OR (x0 = ((3), (0))) OR (x0 = ((4), (0))) OR (x0 = ((5), (0))) OR (x0 = ((6), (0)))}"
    "finite_set[[nat, nat]]")))
 (split_simple 0
  (split_simple-1 nil 3743347561
   ("" (grind)
    (("1" (expand "foldr")
      (("1" (grind)
        (("1"
          (use "member_null"
               ("x" "(1, 0)" "l" "set2list({x0: [nat, nat] |
                             (x0 = ((1), (0))) OR (x0 = ((2), (0)))
                         OR (x0 = ((3), (0))) OR (x0 = ((4), (0)))
                         OR (x0 = ((5), (0))) OR (x0 = ((6), (0)))})"))
          (("1" (grind)
            (("1" (expand "set2list") (("1" (grind) nil nil)) nil))
            nil)
           ("2"
            (inst 1 "6" "LAMBDA (x: {x0: [nat, nat] |
                          (x0 = ((1), (0))) OR (x0 = ((2), (0)))
                      OR (x0 = ((3), (0))) OR (x0 = ((4), (0)))
                      OR (x0 = ((5), (0))) OR (x0 = ((6), (0)))}): pred(x`1)")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil)
         ("2" (postpone) nil nil) ("3" (postpone) nil nil)
         ("4" (postpone) nil nil) ("5" (postpone) nil nil))
        nil))
      nil)
     ("2" (postpone) nil nil))
    nil)
   nil shostak))
 (isSubsetOf_1 0
  (isSubsetOf_1-1 nil 3743347988 ("" (grind) nil nil)
   ((emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset? const-decl "bool" set_extra nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (isSubsetOf_2 0
  (isSubsetOf_2-1 nil 3743347994 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset? const-decl "bool" set_extra nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   shostak))
 (isSubsetOf_3 0
  (isSubsetOf_3-1 nil 3743348001 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset? const-decl "bool" set_extra nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   shostak))
 (isSubsetOf_refl 0
  (isSubsetOf_refl-1 nil 3743348006 ("" (grind) nil nil)
   ((member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset? const-decl "bool" set_extra nil))
   shostak))
 (isSubsetOf_def 0
  (isSubsetOf_def-1 nil 3743348016 ("" (grind) nil nil)
   ((A decl-formal-type nil lem_set_aux nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset? const-decl "bool" set_extra nil)
    (member const-decl "bool" set_extra nil)
    (bool_or const-decl "bool" lib_extra nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (isSubsetOf_eq 0
  (isSubsetOf_eq-1 nil 3743348028
   ("" (grind) (("" (decompose-equality) (("" (grind) nil nil)) nil))
    nil)
   ((set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (A decl-formal-type nil lem_set_aux nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool_and const-decl "bool" lib_extra nil)
    (subset? const-decl "bool" set_extra nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (isProperSubsetOf_1 0
  (isProperSubsetOf_1-1 nil 3743348054 ("" (grind) nil nil)
   ((emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (strict_subset? const-decl "bool" sets nil)
    (strict_subset? const-decl "bool" set_extra nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (strict_subset_is_strict_order name-judgement
     "(strict_order?[set[T]])" sets_lemmas nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (isProperSubsetOf_2 0
  (isProperSubsetOf_2-1 nil 3743348062 ("" (grind) nil nil)
   ((member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (strict_subset? const-decl "bool" sets nil)
    (strict_subset? const-decl "bool" set_extra nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (strict_subset_is_strict_order name-judgement
     "(strict_order?[set[T]])" sets_lemmas nil))
   shostak))
 (isProperSubsetOf_3 0
  (isProperSubsetOf_3-1 nil 3743348068
   ("" (grind)
    (("" (decompose-equality)
      (("" (inst -1 "3") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (strict_subset_is_strict_order name-judgement
     "(strict_order?[set[T]])" sets_lemmas nil)
    (strict_subset? const-decl "bool" set_extra nil)
    (strict_subset? const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   shostak))
 (isProperSubsetOf_irrefl 0
  (isProperSubsetOf_irrefl-1 nil 3743348111 ("" (grind) nil nil)
   ((member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (strict_subset? const-decl "bool" sets nil)
    (strict_subset? const-decl "bool" set_extra nil))
   shostak))
 (isProperSubsetOf_def 0
  (isProperSubsetOf_def-1 nil 3743348119
   ("" (grind) (("" (decompose-equality) (("" (grind) nil nil)) nil))
    nil)
   ((set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (A decl-formal-type nil lem_set_aux nil)
    (boolean nonempty-type-decl nil booleans nil)
    (eqs const-decl "bool" lib_extra nil)
    (bool_and const-decl "bool" lib_extra nil)
    (subset? const-decl "bool" set_extra nil)
    (strict_subset? const-decl "bool" set_extra nil)
    (strict_subset? const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   shostak))
 (bigunion_def_lemma_TCC1 0
  (bigunion_def_lemma_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil)
   nil nil
   (bigunion_def_lemma subtype "lem_set_aux.bs" "finite_set[set[A]]")))
 (bigunion_def_lemma_TCC2 0
  (bigunion_def_lemma_TCC2-1 nil 3743265456 ("" (subtype-tcc) nil nil)
   nil nil
   (bigunion_def_lemma subtype "lem_set_aux.s" "finite_set[A]")))
 (bigunion_def_lemma 0
  (bigunion_def_lemma-1 nil 3743348134
   ("" (grind)
    (("" (expand "foldr")
      (("" (grind)
        (("1" (postpone) nil nil) ("2" (postpone) nil nil)
         ("3" (postpone) nil nil))
        nil))
      nil))
    nil)
   nil shostak))
 (bigunion_0 0
  (bigunion_0-1 nil 3743348413
   ("" (grind)
    (("" (expand "bigunion")
      (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((bigunion const-decl "set[A]" set_extra nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member const-decl "bool" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (bigunion_1 0
  (bigunion_1-1 nil 3743351717
   ("" (grind)
    (("" (expand "Union")
      (("" (grind)
        (("" (decompose-equality)
          (("" (grind)
            (("1"
              (inst 1 "{x1: nat | x1 = (1) OR x1 = (2) OR x1 = (3)}")
              nil nil)
             ("2"
              (inst 1 "{x1: nat | x1 = (1) OR x1 = (2) OR x1 = (3)}")
              nil nil)
             ("3"
              (inst 1 "{x1: nat | x1 = (1) OR x1 = (2) OR x1 = (3)}")
              nil nil)
             ("4"
              (inst 1 "{x2: nat | x2 = (3) OR x2 = (2) OR x2 = (4)}")
              nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Union const-decl "set" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (eqs const-decl "bool" lib_extra nil)
    (bigunion const-decl "set[A]" set_extra nil))
   shostak))
 (bigunion_2 0
  (bigunion_2-1 nil 3743348450
   ("" (grind)
    (("" (expand "Union")
      (("" (grind)
        (("" (decompose-equality)
          (("" (grind)
            (("1"
              (inst 1 "{x2: nat | x2 = (1) OR x2 = (2) OR x2 = (3)}")
              nil nil)
             ("2"
              (inst 1 "{x2: nat | x2 = (1) OR x2 = (2) OR x2 = (3)}")
              nil nil)
             ("3"
              (inst 1 "{x2: nat | x2 = (1) OR x2 = (2) OR x2 = (3)}")
              nil nil)
             ("4"
              (inst 1 "{x1: nat | x1 = (3) OR x1 = (2) OR x1 = (4)}")
              nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Union const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (emptyset const-decl "set" sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (eqs const-decl "bool" lib_extra nil)
    (bigunion const-decl "set[A]" set_extra nil))
   shostak))
 (bigunion_3 0
  (bigunion_3-1 nil 3743351873
   ("" (grind)
    (("" (expand "Union")
      (("" (decompose-equality)
        (("" (grind)
          (("1" (inst 1 "{x2: nat | x2 = (1) OR x2 = (2) OR x2 = (3)}")
            nil nil)
           ("2" (inst 1 "{x2: nat | x2 = (1) OR x2 = (2) OR x2 = (3)}")
            nil nil)
           ("3" (inst 1 "{x2: nat | x2 = (1) OR x2 = (2) OR x2 = (3)}")
            nil nil)
           ("4" (inst 1 "{x1: nat | x1 = (3) OR x1 = (2) OR x1 = (4)}")
            nil nil)
           ("5" (inst 1 "{x3: nat | x3 = (5)}") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((Union const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (eqs const-decl "bool" lib_extra nil)
    (bigunion const-decl "set[A]" set_extra nil))
   shostak))
 (bigunion_in 0
  (bigunion_in-1 nil 3743349362 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (A decl-formal-type nil lem_set_aux nil)
    (set type-eq-decl nil sets nil)
    (bigunion const-decl "set[A]" set_extra nil)
    (Union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (member const-decl "bool" set_extra nil)
    (bool_and const-decl "bool" lib_extra nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (difference_1 0
  (difference_1-1 nil 3743351927
   ("" (grind)
    (("" (expand "difference")
      (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((difference const-decl "set" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (eqs const-decl "bool" lib_extra nil)
    (difference const-decl "set[A]" set_extra nil))
   shostak))
 (difference_in 0
  (difference_in-1 nil 3743351946 ("" (grind) nil nil)
   ((difference const-decl "set[A]" set_extra nil)
    (member const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (member const-decl "bool" set_extra nil)
    (bool_and const-decl "bool" lib_extra nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (intersection_1 0
  (intersection_1-1 nil 3743351952
   ("" (grind)
    (("" (expand "intersection")
      (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((intersection const-decl "set" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (eqs const-decl "bool" lib_extra nil)
    (intersection const-decl "set[A]" set_extra nil))
   shostak))
 (intersection_in 0
  (intersection_in-1 nil 3743351969 ("" (grind) nil nil)
   ((intersection const-decl "set[A]" set_extra nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (member const-decl "bool" set_extra nil)
    (bool_and const-decl "bool" lib_extra nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (map_def_lemma_TCC1 0
  (map_def_lemma_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil (map_def_lemma subtype "lem_set_aux.s" "finite_set[A]")))
 (map_def_lemma 0
  (map_def_lemma-1 nil 3743351980
   ("" (grind)
    (("" (expand "map")
      (("" (expand "foldr")
        (("" (grind)
          (("1" (case "s!1 = emptyset[A]")
            (("1" (expand "emptyset")
              (("1" (decompose-equality)
                (("1" (grind)
                  (("1" (decompose-equality) (("1" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (case "set2list(s!1) = null")
                (("1" (expand "set2list")
                  (("1" (grind)
                    (("1" (expand "emptyset")
                      (("1" (decompose-equality)
                        (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "set2list") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (expand "foldr")
            (("2" (grind)
              (("1" (hide 1)
                (("1" (expand "add")
                  (("1" (decompose-equality)
                    (("1" (expand "set2list")
                      (("1" (grind)
                        (("1" (grind) (("1" (postpone) nil nil)) nil)
                         ("2" (postpone) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (postpone) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (map_1 0
  (map_1-1 nil 3743352962
   ("" (grind)
    (("" (expand "map")
      (("" (decompose-equality)
        (("" (iff)
          (("" (prop)
            (("1" (grind) nil nil)
             ("2" (inst 1 "4") (("2" (grind) nil nil)) nil)
             ("3" (inst 1 "3") (("3" (grind) nil nil)) nil)
             ("4" (inst 1 "2") (("4" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((map const-decl "set[B]" set_extra nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (succ const-decl "nat" naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (map_2 0
  (map_2-1 nil 3743353115
   ("" (grind)
    (("" (expand "map")
      (("" (decompose-equality)
        (("" (iff)
          (("" (prop)
            (("1" (grind) nil nil)
             ("2" (inst 1 "2") (("2" (grind) nil nil)) nil)
             ("3" (inst 1 "3") (("3" (grind) nil nil)) nil)
             ("4" (inst 1 "4") (("4" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((map const-decl "set[B]" set_extra nil)
    (odd_times_odd_is_odd application-judgement "odd_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (bigunionmap_0 0
  (bigunionmap_0-1 nil 3743353155
   ("" (grind)
    (("" (expand "map")
      (("" (expand "Union")
        (("" (grind)
          (("" (decompose-equality)
            (("" (iff)
              (("" (prop)
                (("1" (grind) nil nil)
                 ("2"
                  (inst 1 "{x0: nat |
                           x0 = 1 OR x0 = 2 OR x0 = 3}")
                  (("1" (grind) nil nil)
                   ("2" (inst 1 "1")
                    (("2" (decompose-equality) nil nil)) nil))
                  nil)
                 ("3"
                  (inst 1 "{x0: nat |
                           x0 = 1 OR x0 = 2 OR x0 = 3}")
                  (("1" (grind) nil nil)
                   ("2" (inst 1 "1")
                    (("2" (decompose-equality) nil nil)) nil))
                  nil)
                 ("4"
                  (inst 1 "{x0: nat |
                           x0 = 1 OR x0 = 2 OR x0 = 3}")
                  (("1" (grind) nil nil)
                   ("2" (inst 1 "1")
                    (("2" (decompose-equality) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((map const-decl "set[B]" set_extra nil)
    (odd_times_odd_is_odd application-judgement "odd_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil) (Union const-decl "set" sets nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (eqs const-decl "bool" lib_extra nil)
    (map_union const-decl "set[B]" set_extra nil)
    (bigunion const-decl "set[A]" set_extra nil))
   shostak))
 (bigunionmap_1 0
  (bigunionmap_1-1 nil 3743353410
   ("" (grind)
    (("" (expand "map")
      (("" (expand "Union")
        (("" (grind)
          (("" (decompose-equality)
            (("" (iff)
              (("" (prop)
                (("1" (grind) nil nil)
                 ("2"
                  (inst 1 "{x0: nat |
                           x0 = 2 OR x0 = 4 OR x0 = 6}")
                  (("1" (grind) nil nil)
                   ("2" (inst 1 "2")
                    (("2" (decompose-equality) nil nil)) nil))
                  nil)
                 ("3"
                  (inst 1 "{x0: nat |
                           x0 = 2 OR x0 = 4 OR x0 = 6}")
                  (("1" (grind) nil nil)
                   ("2" (inst 1 "2")
                    (("2" (decompose-equality) nil nil)) nil))
                  nil)
                 ("4"
                  (inst 1 "{x0: nat |
                           x0 = 2 OR x0 = 4 OR x0 = 6}")
                  (("1" (grind) nil nil)
                   ("2" (inst 1 "2")
                    (("2" (decompose-equality) nil nil)) nil))
                  nil)
                 ("5"
                  (inst 1 "{x0: nat |
                           x0 = 8 OR x0 = 16 OR x0 = 24}")
                  (("1" (grind) nil nil)
                   ("2" (inst 1 "8")
                    (("2" (decompose-equality) nil nil)) nil))
                  nil)
                 ("6"
                  (inst 1 "{x0: nat |
                           x0 = 8 OR x0 = 16 OR x0 = 24}")
                  (("1" (grind) nil nil)
                   ("2" (inst 1 "8")
                    (("2" (decompose-equality) nil nil)) nil))
                  nil)
                 ("7"
                  (inst 1 "{x0: nat |
                           x0 = 8 OR x0 = 16 OR x0 = 24}")
                  (("1" (grind) nil nil)
                   ("2" (inst 1 "8")
                    (("2" (decompose-equality) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((map const-decl "set[B]" set_extra nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil) (Union const-decl "set" sets nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (eqs const-decl "bool" lib_extra nil)
    (map_union const-decl "set[B]" set_extra nil)
    (bigunion const-decl "set[A]" set_extra nil))
   shostak))
 (fromList_1 0
  (fromList_1-1 nil 3743353554
   ("" (grind)
    (("" (expand "extend")
      (("" (expand "add")
        (("" (expand "emptyset")
          (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((extend const-decl "R" extend nil)
    (emptyset const-decl "set" sets nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (FALSE const-decl "bool" booleans nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[T]" set_as_list "structures/")
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (from_list def-decl "set[A]" set_extra nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (fromList_2 0
  (fromList_2-1 nil 3743353583
   ("" (grind)
    (("" (expand "extend")
      (("" (expand "add")
        (("" (expand "emptyset")
          (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((extend const-decl "R" extend nil)
    (emptyset const-decl "set" sets nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (FALSE const-decl "bool" booleans nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[T]" set_as_list "structures/")
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (from_list def-decl "set[A]" set_extra nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (fromList_3 0
  (fromList_3-1 nil 3743353608 ("" (grind) nil nil)
   ((from_list def-decl "set[A]" set_extra nil)
    (eqs const-decl "bool" lib_extra nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (sigma_def_lemma_TCC1 0
  (sigma_def_lemma_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil (sigma_def_lemma subtype "lem_set_aux.sa" "finite_set[A]")))
 (sigma_def_lemma_TCC2 0
  (sigma_def_lemma_TCC2-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil
   (sigma_def_lemma subtype "lem_set_aux.sb(lem_set_aux.a)"
    "finite_set[B]")))
 (sigma_def_lemma 0
  (sigma_def_lemma-1 nil 3743353616
   ("" (grind) (("" (postpone) nil nil)) nil) nil shostak))
 (Sigma_1 0
  (Sigma_1-1 nil 3743349403
   ("" (grind)
    (("" (expand "sigma")
      (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((sigma const-decl "set[[A, B]]" set_extra nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (Sigma_2 0
  (Sigma_2-1 nil 3743349425 ("" (grind) nil nil)
   ((member const-decl "bool" sets nil)
    (sigma const-decl "set[[A, B]]" set_extra nil)
    (member const-decl "bool" set_extra nil)
    (bool_and const-decl "bool" lib_extra nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (cross_def_lemma_TCC1 0
  (cross_def_lemma_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil (cross_def_lemma subtype "lem_set_aux.s2" "finite_set[B]")))
 (cross_def_lemma_TCC2 0
  (cross_def_lemma_TCC2-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil (cross_def_lemma subtype "lem_set_aux.s1" "finite_set[A]")))
 (cross_def_lemma_TCC3 0
  (cross_def_lemma_TCC3-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil (cross_def_lemma subtype "lem_set_aux.s1" "finite_set[A]")))
 (cross_def_lemma_TCC4 0
  (cross_def_lemma_TCC4-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil (cross_def_lemma subtype "lem_set_aux.s2" "finite_set[B]")))
 (cross_def_lemma 0
  (cross_def_lemma-1 nil 3743349435 ("" (grind) nil nil)
   ((add const-decl "set[A]" set_extra nil)
    (cross const-decl "set[[A, B]]" set_extra nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (cross_by_sigma_TCC1 0
  (cross_by_sigma_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil (cross_by_sigma subtype "lem_set_aux.s2" "finite_set[B]")))
 (cross_by_sigma_TCC2 0
  (cross_by_sigma_TCC2-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil
   nil (cross_by_sigma subtype "lem_set_aux.s1" "finite_set[A]")))
 (cross_by_sigma 0
  (cross_by_sigma-1 nil 3743349440
   ("" (grind)
    (("" (expand "sigma")
      (("" (expand "foldr")
        (("" (grind)
          (("1" (case "s1!1 = emptyset[A]")
            (("1" (grind)
              (("1" (decompose-equality)
                (("1" (grind)
                  (("1" (expand "emptyset") (("1" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (postpone) nil nil))
            nil)
           ("2" (expand "foldr")
            (("2" (grind)
              (("1" (expand "emptyset")
                (("1" (decompose-equality)
                  (("1" (grind) (("1" (postpone) nil nil)) nil)) nil))
                nil)
               ("2" (postpone) nil nil))
              nil))
            nil)
           ("3" (postpone) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (cross_1_TCC1 0
  (cross_1_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil
   (cross_1 subtype
    "{x1: booleans.bool | booleans.OR(x1, x1 = booleans.FALSE)}"
    "finite_set[boolean]")))
 (cross_1_TCC2 0
  (cross_1_TCC2-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil
   (cross_1 subtype
    "{x0: naturalnumbers.nat | booleans.OR(x0 = (2), x0 = (3))}"
    "finite_set[nat]")))
 (cross_1 0
  (cross_1-1 nil 3743353697 ("" (grind) (("" (postpone) nil nil)) nil)
   nil shostak))
 (lfp_empty_0 0
  (lfp_empty_0-1 nil 3743272231 ("" (grind) nil nil)
   ((instance_Basic_classes_SetType_nat_dict const-decl
     "setType_class[nat]" lem_num nil)
    (eqs const-decl "bool" lib_extra nil)
    (leastFixedPoint def-decl "set[A]" lem_set nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (lfp_empty_1 0
  (lfp_empty_1-1 nil 3743272236
   ("" (grind)
    (("" (expand "union")
      (("" (expand "member")
        (("" (expand "emptyset")
          (("" (expand "map")
            (("" (decompose-equality)
              (("" (grind) (("" (postpone) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((instance_Basic_classes_SetType_nat_dict const-decl
     "setType_class[nat]" lem_num nil)
    (eqs const-decl "bool" lib_extra nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (map const-decl "set[B]" set_extra nil)
    (subset? const-decl "bool" sets nil)
    (subset? const-decl "bool" set_extra nil)
    (leastFixedPoint def-decl "set[A]" lem_set nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_emptyset name-judgement "finite_set[T]" set_as_list
     "structures/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (lfp_saturate_neg_1_TCC1 0
  (lfp_saturate_neg_1_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (member const-decl "bool" sets nil)
    (map const-decl "set[B]" set_extra nil))
   nil
   (lfp_saturate_neg_1 subtype
    "set_extra.map((LAMBDA (x: integers.int): ))"
    "[set[int] -> set[int]]")))
 (lfp_saturate_neg_1 0
  (lfp_saturate_neg_1-1 nil 3743355743
   ("" (expand "eqs")
    (("" (expand "leastFixedPoint")
      (("" (case "eqs(1)(0)")
        (("1" (replace -1) (("1" (grind) nil nil)) nil)
         ("2" (replaces 1)
          (("2" (decompose-equality)
            (("1" (iff)
              (("1" (prop)
                (("1" (expand "leastFixedPoint")
                  (("1" (grind) nil nil)) nil)
                 ("2" (hide -2 1 2 3)
                  (("2" (expand "map")
                    (("2" (expand "subset?")
                      (("2" (expand "subset?")
                        (("2" (inst -1 "-1") (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (expand "leastFixedPoint")
                  (("3" (grind) nil nil)) nil)
                 ("4" (hide -2 1 2 3)
                  (("4" (expand "map")
                    (("4" (expand "subset?")
                      (("4" (expand "subset?")
                        (("4" (inst -1 "-1") (("4" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (expand "leastFixedPoint")
                  (("5" (grind) nil nil)) nil)
                 ("6" (expand "map")
                  (("6" (expand "subset?")
                    (("6" (expand "subset?")
                      (("6" (inst -1 "-1")
                        (("6" (hide -2 1 2 3) (("6" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("7" (expand "leastFixedPoint")
                  (("7" (grind) nil nil)) nil)
                 ("8" (expand "leastFixedPoint")
                  (("8" (grind) nil nil)) nil)
                 ("9" (expand "leastFixedPoint")
                  (("9" (grind) nil nil)) nil)
                 ("10" (expand "leastFixedPoint")
                  (("10" (grind) nil nil)) nil))
                nil))
              nil)
             ("2" (prop)
              (("2" (hide 1)
                (("2" (expand "map") (("2" (grind) nil nil)) nil))
                nil))
              nil)
             ("3" (prop) (("3" (hide 1) (("3" (grind) nil nil)) nil))
              nil)
             ("4" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((leastFixedPoint def-decl "set[A]" lem_set nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (union const-decl "set[A]" set_extra nil)
    (instance_Basic_classes_SetType_Num_int_dict const-decl
     "setType_class[int]" lem_num nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (setType_class type-eq-decl nil lem_basic_classes nil)
    (ordering type-eq-decl nil lib_extra nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subset? const-decl "bool" set_extra nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (map const-decl "set[B]" set_extra nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (eqs const-decl "bool" lib_extra nil))
   shostak))
 (lfp_saturate_neg_2 0
  (lfp_saturate_neg_2-1 nil 3743357105
   ("" (expand "eqs")
    (("" (expand "leastFixedPoint")
      (("" (case "eqs(2)(0)")
        (("1" (replace -1) (("1" (grind) nil nil)) nil)
         ("2" (replaces 1)
          (("2" (decompose-equality)
            (("1" (iff)
              (("1" (prop)
                (("1" (expand "leastFixedPoint")
                  (("1" (grind) nil nil)) nil)
                 ("2" (hide -2 1 2 3)
                  (("2" (expand "map")
                    (("2" (expand "subset?")
                      (("2" (expand "subset?")
                        (("2" (inst -1 "-1") (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (hide 1)
                  (("3" (expand "leastFixedPoint")
                    (("3" (postpone) nil nil)) nil))
                  nil)
                 ("4" (postpone) nil nil) ("5" (postpone) nil nil)
                 ("6" (postpone) nil nil) ("7" (postpone) nil nil)
                 ("8" (postpone) nil nil) ("9" (postpone) nil nil)
                 ("10" (postpone) nil nil))
                nil))
              nil)
             ("2" (postpone) nil nil) ("3" (postpone) nil nil)
             ("4" (postpone) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)))

