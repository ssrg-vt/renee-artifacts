("lem_maybe_aux" lem_maybe_aux isJust_1 0 (isJust_1-1 nil 3742834884 ("" (grind) nil nil) ((isJust const-decl "bool" lem_maybe nil)) shostak))("lem_maybe_aux" lem_maybe_aux maybe_eq_4 0 (maybe_eq_4-1 nil 3742833882 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_maybe_aux" lem_maybe_aux maybe_1 0 (maybe_1-1 nil 3742837524 ("" (grind) nil nil) ((maybe const-decl "B" lem_maybe nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux maybe_2 0 (maybe_2-1 nil 3742837541 ("" (grind) nil nil) ((maybe const-decl "B" lem_maybe nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux maybe_3 0 (maybe_3-1 nil 3742837547 ("" (grind) nil nil) ((maybe const-decl "B" lem_maybe nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux maybe_4 0 (maybe_4-1 nil 3742837552 ("" (grind) nil nil) ((maybe const-decl "B" lem_maybe nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux isJust_2 0 (isJust_2-1 nil 3742837556 ("" (grind) nil nil) ((isJust const-decl "bool" lem_maybe nil)) shostak))("lem_maybe_aux" lem_maybe_aux isNothing_1 0 (isNothing_1-1 nil 3742837561 ("" (grind) nil nil) ((isNothing const-decl "bool" lem_maybe nil)) shostak))("lem_maybe_aux" lem_maybe_aux isNothing_2 0 (isNothing_2-1 nil 3742837565 ("" (grind) nil nil) ((isNothing const-decl "bool" lem_maybe nil)) shostak))("lem_maybe_aux" lem_maybe_aux isJustNothing 0 (isJustNothing-1 nil 3742837569 ("" (grind) nil nil) ((isNothing const-decl "bool" lem_maybe nil) (isJust const-decl "bool" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (bool_and const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux fromMaybe 0 (fromMaybe-1 nil 3742837574 ("" (grind) nil nil) ((fromMaybe const-decl "A" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (bool_and const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux fromMaybe_1 0 (fromMaybe_1-1 nil 3742837578 ("" (grind) nil nil) ((fromMaybe const-decl "A" lem_maybe nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux fromMaybe_2 0 (fromMaybe_2-1 nil 3742837583 ("" (grind) nil nil) ((fromMaybe const-decl "A" lem_maybe nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux fromMaybe_3 0 (fromMaybe_3-1 nil 3742837587 ("" (grind) nil nil) ((fromMaybe const-decl "A" lem_maybe nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux fromMaybe_4 0 (fromMaybe_4-1 nil 3742837591 ("" (grind) nil nil) ((fromMaybe const-decl "A" lem_maybe nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux maybe_map 0 (maybe_map-1 nil 3742837598 ("" (grind) nil nil) ((map const-decl "[option[A] -> option[B]]" lem_maybe nil) (maybe const-decl "B" lem_maybe nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (bool_and const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux map_1 0 (map_1-1 nil 3742837602 ("" (grind) nil nil) ((map const-decl "[option[A] -> option[B]]" lem_maybe nil) (maybe const-decl "B" lem_maybe nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_maybe_aux" lem_maybe_aux map_2 0 (map_2-1 nil 3742837606 ("" (grind) nil nil) ((map const-decl "[option[A] -> option[B]]" lem_maybe nil) (maybe const-decl "B" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_maybe_aux" lem_maybe_aux map_3 0 (map_3-1 nil 3742837610 ("" (grind) nil nil) ((map const-decl "[option[A] -> option[B]]" lem_maybe nil) (maybe const-decl "B" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_maybe_aux" lem_maybe_aux maybe_bind 0 (maybe_bind-1 nil 3742837614 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (maybe const-decl "B" lem_maybe nil) (bind const-decl "option[B]" lem_maybe nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (bool_and const-decl "bool" lib_extra nil)) shostak))("lem_maybe_aux" lem_maybe_aux bind_1 0 (bind_1-1 nil 3742837618 ("" (grind) nil nil) ((maybe const-decl "B" lem_maybe nil) (bind const-decl "option[B]" lem_maybe nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_maybe_aux" lem_maybe_aux bind_2 0 (bind_2-1 nil 3742837625 ("" (grind) nil nil) ((maybe const-decl "B" lem_maybe nil) (bind const-decl "option[B]" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_maybe_aux" lem_maybe_aux bind_3 0 (bind_3-1 nil 3742837629 ("" (grind) nil nil) ((maybe const-decl "B" lem_maybe nil) (bind const-decl "option[B]" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_maybe_aux" lem_maybe_aux bind_4 0 (bind_4-1 nil 3742837633 ("" (grind) nil nil) ((maybe const-decl "B" lem_maybe nil) (bind const-decl "option[B]" lem_maybe nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_num_aux" lem_num_aux int32FromInteger_def_lemma_TCC1 0 (int32FromInteger_def_lemma_TCC1-1 nil 3742920976 ("" (subtype-tcc) nil nil) nil nil (int32FromInteger_def_lemma subtype "(lem_num_aux.i)" "nat")))("set_extra" set_extra set2list_emptyset_TCC1 0 (set2list_emptyset_TCC1-1 nil 3743353835 ("" (subtype-tcc) nil nil) nil nil (set2list_emptyset subtype "set_extra.s" "finite_set[T]")))("set_extra" set_extra set2list_eq_card_TCC1 0 (set2list_eq_card_TCC1-1 nil 3743353921 ("" (subtype-tcc) nil nil) nil nil (set2list_eq_card subtype "set_extra.s" "finite_set[T]")))("set_extra" set_extra set2list_eq_card_TCC2 0 (set2list_eq_card_TCC2-1 nil 3743353921 ("" (subtype-tcc) nil nil) nil nil (set2list_eq_card subtype "set_extra.s" "finite_set[T]")))("lem_list_aux" lem_list_aux map_1 0 (map_1-1 nil 3743182951 ("" (grind) nil nil) ((map adt-def-decl "list[T1]" list_adt_map nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak))("lem_list_aux" lem_list_aux map_2_TCC1 0 (map_2_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (map_2 subtype "list_adt[real].cons((1), list_adt[real].null)" "list[nat]")))("lem_list_aux" lem_list_aux map_2 0 (map_2-1 nil 3743182956 ("" (grind) nil nil) ((map adt-def-decl "list[T1]" list_adt_map nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak))("lem_list_aux" lem_list_aux map_3_TCC1 0 (map_3_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (map_3 subtype "list_adt[real].cons((1), list_adt[real].cons((2), list_adt[real].null))" "list[nat]")))("lem_list_aux" lem_list_aux map_3 0 (map_3-1 nil 3743182961 ("" (grind) nil nil) ((map adt-def-decl "list[T1]" list_adt_map nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak))("lem_list_aux" lem_list_aux map_4_TCC1 0 (map_4_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (map_4 subtype "list_adt[real].cons((1), list_adt[real].cons((2), list_adt[real].cons((3), list_adt[real].null)))" "list[nat]")))("lem_list_aux" lem_list_aux map_4 0 (map_4-1 nil 3743182967 ("" (grind) nil nil) ((map adt-def-decl "list[T1]" list_adt_map nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak))("lem_list_aux" lem_list_aux map_5_TCC1 0 (map_5_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (map_5 subtype "list_adt[real].cons((1), list_adt[real].cons((2), list_adt[real].cons((3), list_adt[real].cons((4), list_adt[real].null))))" "list[nat]")))("lem_list_aux" lem_list_aux map_5 0 (map_5-1 nil 3743182971 ("" (grind) nil nil) ((map adt-def-decl "list[T1]" list_adt_map nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak))("lem_list_aux" lem_list_aux map_6_TCC1 0 (map_6_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (map_6 subtype "list_adt[real].cons((1), list_adt[real].cons((2), list_adt[real].cons((3), list_adt[real].cons((4), list_adt[real].cons((5), list_adt[real].null)))))" "list[nat]")))("lem_list_aux" lem_list_aux map_6 0 (map_6-1 nil 3743182974 ("" (grind) nil nil) ((map adt-def-decl "list[T1]" list_adt_map nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak))("lem_list_aux" lem_list_aux foldl_def_lemma 0 (foldl_def_lemma-1 nil 3743182978 ("" (postpone) nil nil) nil shostak))("lem_list_aux" lem_list_aux foldl_0 0 (foldl_0-1 nil 3743183046 ("" (grind) nil nil) ((foldl def-decl "A" list_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux foldl_1 0 (foldl_1-1 nil 3743183052 ("" (grind) nil nil) ((foldl def-decl "A" list_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux foldl_4_TCC1 0 (foldl_4_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (foldl_4 subtype "list_adt[real].cons((2), list_adt[real].cons((3), list_adt[real].cons((4), list_adt[real].null)))" "list[nat]")))("lem_list_aux" lem_list_aux foldl_4 0 (foldl_4-1 nil 3743183057 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (foldl def-decl "A" list_extra nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux foldr_def_lemma 0 (foldr_def_lemma-1 nil 3743183100 ("" (postpone) nil nil) nil shostak))("lem_list_aux" lem_list_aux foldr_0 0 (foldr_0-1 nil 3743183107 ("" (grind) nil nil) ((foldr def-decl "B" list_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux foldr_1 0 (foldr_1-1 nil 3743183112 ("" (grind) nil nil) ((foldr def-decl "B" list_extra nil) (eqs const-decl "bool" lib_extra nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak))("lem_list_aux" lem_list_aux foldr_4 0 (foldr_4-1 nil 3743183116 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (foldr def-decl "B" list_extra nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux concat_nil 0 (concat_nil-1 nil 3743183120 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (foldr def-decl "B" list_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux concat_1 0 (concat_1-1 nil 3743183127 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (foldr def-decl "B" list_extra nil) (append def-decl "list[T]" list_props nil) (list_append const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux concat_2 0 (concat_2-1 nil 3743183131 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (foldr def-decl "B" list_extra nil) (append def-decl "list[T]" list_props nil) (list_append const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux concat_3 0 (concat_3-1 nil 3743183136 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (foldr def-decl "B" list_extra nil) (append def-decl "list[T]" list_props nil) (list_append const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux concat_emp_thm 0 (concat_emp_thm-1 nil 3743183140 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (foldr def-decl "B" list_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux concat_cons_thm 0 (concat_cons_thm-1 nil 3743183145 ("" (induct "l") (("1" (grind) (("1" (grind) (("1" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil) nil shostak))("lem_list_aux" lem_list_aux concatMap_nil 0 (concatMap_nil-1 nil 3743183178 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (map adt-def-decl "list[T1]" list_adt_map nil) (foldr def-decl "B" list_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux concatMap_1 0 (concatMap_1-1 nil 3743183182 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (map adt-def-decl "list[T1]" list_adt_map nil) (foldr def-decl "B" list_extra nil) (append def-decl "list[T]" list_props nil) (list_append const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux concatMap_2_TCC1 0 (concatMap_2_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (concatMap_2 subtype "list_adt[real].cons((2), list_adt[real].null)" "list[nat]")))("lem_list_aux" lem_list_aux concatMap_2 0 (concatMap_2-1 nil 3743183188 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (map adt-def-decl "list[T1]" list_adt_map nil) (foldr def-decl "B" list_extra nil) (append def-decl "list[T]" list_props nil) (list_append const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux concatMap_3_TCC1 0 (concatMap_3_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (concatMap_3 subtype "list_adt[real].cons((2), list_adt[real].cons((3), list_adt[real].null))" "list[nat]")))("lem_list_aux" lem_list_aux concatMap_3 0 (concatMap_3-1 nil 3743183194 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (map adt-def-decl "list[T1]" list_adt_map nil) (foldr def-decl "B" list_extra nil) (append def-decl "list[T]" list_props nil) (list_append const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux concatMap_concat 0 (concatMap_concat-1 nil 3743183200 ("" (induct "ll") (("1" (grind) nil nil) ("2" (grind) (("2" (postpone) nil nil)) nil)) nil) nil shostak))("lem_list_aux" lem_list_aux all_0 0 (all_0-1 nil 3743183237 ("" (grind) nil nil) ((every adt-def-decl "boolean" list_adt nil)) shostak))("lem_list_aux" lem_list_aux all_4_TCC1 0 (all_4_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (all_4 subtype "list_adt[real].cons((5), list_adt[real].cons((6), list_adt[real].cons((7), list_adt[real].null)))" "list[nat]")))("lem_list_aux" lem_list_aux all_4 0 (all_4-1 nil 3743183243 ("" (grind) nil nil) ((every adt-def-decl "boolean" list_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux all_4_neg_TCC1 0 (all_4_neg_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (all_4_neg subtype "list_adt[real].cons((5), list_adt[real].cons((2), list_adt[real].cons((7), list_adt[real].null)))" "list[nat]")))("lem_list_aux" lem_list_aux all_4_neg 0 (all_4_neg-1 nil 3743183247 ("" (grind) nil nil) ((every adt-def-decl "boolean" list_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux all_nil_thm 0 (all_nil_thm-1 nil 3743183252 ("" (grind) nil nil) ((every adt-def-decl "boolean" list_adt nil)) shostak))("lem_list_aux" lem_list_aux all_cons_thm 0 (all_cons_thm-1 nil 3743183256 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (every adt-def-decl "boolean" list_adt nil) (bool_and const-decl "bool" lib_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux any_def_lemma 0 (any_def_lemma-1 nil 3743183260 ("" (grind) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil) nil shostak))("lem_list_aux" lem_list_aux any_0 0 (any_0-1 nil 3743183267 ("" (grind) nil nil) ((some adt-def-decl "boolean" list_adt nil)) shostak))("lem_list_aux" lem_list_aux any_4 0 (any_4-1 nil 3743183276 ("" (grind) nil nil) ((some adt-def-decl "boolean" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux any_4_neg 0 (any_4_neg-1 nil 3743183279 ("" (grind) nil nil) ((some adt-def-decl "boolean" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux any_nil_thm 0 (any_nil_thm-1 nil 3743183283 ("" (grind) nil nil) ((some adt-def-decl "boolean" list_adt nil)) shostak))("lem_list_aux" lem_list_aux any_cons_thm 0 (any_cons_thm-1 nil 3743183285 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (some adt-def-decl "boolean" list_adt nil) (bool_or const-decl "bool" lib_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux dest_init_0 0 (dest_init_0-1 nil 3743183290 ("" (grind) nil nil) ((dest_init const-decl "option[[list[A], A]]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux dest_init_1_TCC1 0 (dest_init_1_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (dest_init_1 subtype "lem_list.dest_init(list_adt[real].cons((1), list_adt[real].null))" "option_adt[[list[nat], nat]].option")))("lem_list_aux" lem_list_aux dest_init_1 0 (dest_init_1-1 nil 3743183293 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil) (dest_init_aux def-decl "[list[A], A]" lem_list nil) (dest_init const-decl "option[[list[A], A]]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil) (eqs const-decl "bool" lib_extra nil) (pair_equal const-decl "bool" lib_extra nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux dest_init_2_TCC1 0 (dest_init_2_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (dest_init_2 subtype "lem_list.dest_init(list_adt[real].cons((1), list_adt[real].cons((2), list_adt[real].cons((3), list_adt[real].cons((4), list_adt[real].cons((5), list_adt[real].null))))))" "option_adt[[list[nat], nat]].option")))("lem_list_aux" lem_list_aux dest_init_2 0 (dest_init_2-1 nil 3743183296 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (dest_init_aux def-decl "[list[A], A]" lem_list nil) (dest_init const-decl "option[[list[A], A]]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (pair_equal const-decl "bool" lib_extra nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux dest_init_nil 0 (dest_init_nil-1 nil 3743183299 ("" (grind) nil nil) ((dest_init const-decl "option[[list[A], A]]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux dest_init_snoc 0 (dest_init_snoc-1 nil 3743183301 ("" (grind) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil) nil shostak))("lem_list_aux" lem_list_aux index_0 0 (index_0-1 nil 3743183365 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (index def-decl "option[A]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux index_1 0 (index_1-1 nil 3743183369 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (index def-decl "option[A]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux index_2 0 (index_2-1 nil 3743183372 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (index def-decl "option[A]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux index_3 0 (index_3-1 nil 3743183374 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (index def-decl "option[A]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux index_4 0 (index_4-1 nil 3743183377 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (index def-decl "option[A]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux index_5 0 (index_5-1 nil 3743183379 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (index def-decl "option[A]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux index_6_TCC1 0 (index_6_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (index_6 subtype "lem_list.index(list_adt[real].cons((0), list_adt[real].cons((1), list_adt[real].cons((2), list_adt[real].cons((3), list_adt[real].cons((4), list_adt[real].cons((5), list_adt[real].null)))))))((6))" "option[nat]")))("lem_list_aux" lem_list_aux index_6 0 (index_6-1 nil 3743183382 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (index def-decl "option[A]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux index_is_none 0 (index_is_none-1 nil 3743183386 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (n!1 skolem-const-decl "nat" lem_list_aux nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (length def-decl "nat" list_props nil) (None adt-constructor-decl "(None?)" option_adt nil) (None? adt-recognizer-decl "[option -> boolean]" option_adt nil) (index def-decl "option[A]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (option type-decl nil option_adt nil) (eqs const-decl "bool" lib_extra nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux index_list_eq 0 (index_list_eq-1 nil 3743183405 ("" (induct "l1") (("1" (induct "l2") (("1" (grind) nil nil) ("2" (grind) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil) nil shostak))("lem_list_aux" lem_list_aux findIndices_1 0 (findIndices_1-1 nil 3743183473 ("" (grind) nil nil) ((findIndices_aux def-decl "list[nat]" lem_list nil) (findIndices const-decl "list[nat]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux findIndices_2 0 (findIndices_2-1 nil 3743183477 ("" (grind) nil nil) ((findIndices_aux def-decl "list[nat]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (findIndices const-decl "list[nat]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux findIndices_3_TCC1 0 (findIndices_3_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (findIndices_3 subtype "list_adt[real].cons((5), list_adt[real].cons((3), list_adt[real].cons((1), list_adt[real].cons((2), list_adt[real].cons((6), list_adt[real].null)))))" "list[nat]")))("lem_list_aux" lem_list_aux findIndices_3 0 (findIndices_3-1 nil 3743183482 ("" (grind) nil nil) ((findIndices_aux def-decl "list[nat]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (findIndices const-decl "list[nat]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux find_index0 0 (find_index0-1 nil 3743183484 ("" (grind) nil nil) ((findIndices_aux def-decl "list[nat]" lem_list nil) (findIndices const-decl "list[nat]" lem_list nil) (findIndex const-decl "option[nat]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux find_index1_TCC1 0 (find_index1_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (find_index1 subtype "list_adt[real].cons((2), list_adt[real].cons((4), list_adt[real].null))" "list[nat]")))("lem_list_aux" lem_list_aux find_index1 0 (find_index1-1 nil 3743183487 ("" (grind) nil nil) ((findIndices_aux def-decl "list[nat]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (findIndices const-decl "list[nat]" lem_list nil) (findIndex const-decl "option[nat]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux find_index2_TCC1 0 (find_index2_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (find_index2 subtype "list_adt[real].cons((2), list_adt[real].cons((4), list_adt[real].cons((5), list_adt[real].cons((67), list_adt[real].cons((1), list_adt[real].null)))))" "list[nat]")))("lem_list_aux" lem_list_aux find_index2 0 (find_index2-1 nil 3743183490 ("" (grind) nil nil) ((findIndices_aux def-decl "list[nat]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (findIndices const-decl "list[nat]" lem_list nil) (findIndex const-decl "option[nat]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux elemIndices_0 0 (elemIndices_0-1 nil 3743183492 ("" (grind) nil nil) ((findIndices_aux def-decl "list[nat]" lem_list nil) (findIndices const-decl "list[nat]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux elemIndices_1 0 (elemIndices_1-1 nil 3743183495 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (findIndices_aux def-decl "list[nat]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (findIndices const-decl "list[nat]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux elemIndices_2 0 (elemIndices_2-1 nil 3743183500 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (findIndices_aux def-decl "list[nat]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (findIndices const-decl "list[nat]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux elemIndex_0 0 (elemIndex_0-1 nil 3743183503 ("" (grind) nil nil) ((findIndices_aux def-decl "list[nat]" lem_list nil) (findIndices const-decl "list[nat]" lem_list nil) (findIndex const-decl "option[nat]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux elemIndex_1 0 (elemIndex_1-1 nil 3743183505 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (findIndices_aux def-decl "list[nat]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (findIndices const-decl "list[nat]" lem_list nil) (findIndex const-decl "option[nat]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux elemIndex_2 0 (elemIndex_2-1 nil 3743183509 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (findIndices_aux def-decl "list[nat]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (findIndices const-decl "list[nat]" lem_list nil) (findIndex const-decl "option[nat]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux genlist_0 0 (genlist_0-1 nil 3743183511 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (genlist def-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux genlist_1 0 (genlist_1-1 nil 3743183514 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (genlist def-decl "list[A]" lem_list nil) (append def-decl "list[T]" list_props nil) (list_append const-decl "list[T]" list_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux genlist_2 0 (genlist_2-1 nil 3743183516 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (genlist def-decl "list[A]" lem_list nil) (append def-decl "list[T]" list_props nil) (list_append const-decl "list[T]" list_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux genlist_3 0 (genlist_3-1 nil 3743183518 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (genlist def-decl "list[A]" lem_list nil) (append def-decl "list[T]" list_props nil) (list_append const-decl "list[T]" list_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux genlist_length 0 (genlist_length-1 nil 3743183521 ("" (grind) (("" (postpone) nil nil)) nil) nil shostak))("lem_list_aux" lem_list_aux genlist_index 0 (genlist_index-1 nil 3743183564 ("" (grind) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil) nil shostak))("lem_list_aux" lem_list_aux replicate_0 0 (replicate_0-1 nil 3743183575 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (replicate def-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux replicate_1 0 (replicate_1-1 nil 3743183579 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (replicate def-decl "list[A]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux replicate_2 0 (replicate_2-1 nil 3743183581 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (replicate def-decl "list[A]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux replicate_3 0 (replicate_3-1 nil 3743183584 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (replicate def-decl "list[A]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux splitAt_1_TCC1 0 (splitAt_1_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (splitAt_1 subtype "list_adt[real].cons((2), list_adt[real].cons((3), list_adt[real].cons((4), list_adt[real].cons((5), list_adt[real].cons((6), list_adt[real].null)))))" "list[nat]")))("lem_list_aux" lem_list_aux splitAt_1 0 (splitAt_1-1 nil 3743183588 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil) (splitAtAcc def-decl "[list[A], list[A]]" lem_list nil) (splitAt const-decl "[list[A], list[A]]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil) (eqs const-decl "bool" lib_extra nil) (pair_equal const-decl "bool" lib_extra nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux splitAt_2_TCC1 0 (splitAt_2_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (splitAt_2 subtype "lem_list.splitAt((2))(list_adt[real].cons((1), list_adt[real].cons((2), list_adt[real].cons((3), list_adt[real].cons((4), list_adt[real].cons((5), list_adt[real].cons((6), list_adt[real].null)))))))" "[(list_adt[real].cons?), (list_adt[real].cons?)]")))("lem_list_aux" lem_list_aux splitAt_2_TCC2 0 (splitAt_2_TCC2-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (splitAt_2 subtype "restrict[list[real], (list_adt[real].cons?), [list[real] -> booleans.bool]].restrict(lem_list.listEqualBy(lib_extra.eqs))" "[(list_adt[real].cons?) -> [(list_adt[real].cons?) -> booleans.bool]]")))("lem_list_aux" lem_list_aux splitAt_2 0 (splitAt_2-1 nil 3743183592 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitAtAcc def-decl "[list[A], list[A]]" lem_list nil) (splitAt const-decl "[list[A], list[A]]" lem_list nil) (restrict const-decl "R" restrict nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (pair_equal const-decl "bool" lib_extra nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux splitAt_3 0 (splitAt_3-1 nil 3743183596 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitAtAcc def-decl "[list[A], list[A]]" lem_list nil) (splitAt const-decl "[list[A], list[A]]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (pair_equal const-decl "bool" lib_extra nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux take_1 0 (take_1-1 nil 3743183601 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil) (splitAtAcc def-decl "[list[A], list[A]]" lem_list nil) (splitAt const-decl "[list[A], list[A]]" lem_list nil) (take const-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux take_2 0 (take_2-1 nil 3743183604 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitAtAcc def-decl "[list[A], list[A]]" lem_list nil) (splitAt const-decl "[list[A], list[A]]" lem_list nil) (take const-decl "list[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux take_3 0 (take_3-1 nil 3743183606 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitAtAcc def-decl "[list[A], list[A]]" lem_list nil) (splitAt const-decl "[list[A], list[A]]" lem_list nil) (take const-decl "list[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux drop_1 0 (drop_1-1 nil 3743183609 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil) (splitAtAcc def-decl "[list[A], list[A]]" lem_list nil) (splitAt const-decl "[list[A], list[A]]" lem_list nil) (drop const-decl "list[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux drop_2 0 (drop_2-1 nil 3743183614 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitAtAcc def-decl "[list[A], list[A]]" lem_list nil) (splitAt const-decl "[list[A], list[A]]" lem_list nil) (drop const-decl "list[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux drop_3 0 (drop_3-1 nil 3743183616 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitAtAcc def-decl "[list[A], list[A]]" lem_list nil) (splitAt const-decl "[list[A], list[A]]" lem_list nil) (drop const-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux splitWhile_1_TCC1 0 (splitWhile_1_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (splitWhile_1 subtype "lem_list.splitWhile(LAMBDA (y: naturalnumbers.nat): (reals.>((3), y)))(list_adt[nat].cons((1), list_adt[real].cons((2), list_adt[real].cons((3), list_adt[real].cons((4), list_adt[real].cons((5), list_adt[real].cons((6), list_adt[real].null)))))))" "[(list_adt[real].cons?), (list_adt[real].cons?)]")))("lem_list_aux" lem_list_aux splitWhile_1 0 (splitWhile_1-1 nil 3743183620 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitWhile_tr def-decl "[list[A], list[A]]" lem_list nil) (splitWhile const-decl "[list[A], list[A]]" lem_list nil) (restrict const-decl "R" restrict nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (pair_equal const-decl "bool" lib_extra nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux splitWhile_2 0 (splitWhile_2-1 nil 3743183622 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil) (splitWhile_tr def-decl "[list[A], list[A]]" lem_list nil) (splitWhile const-decl "[list[A], list[A]]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil) (pair_equal const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux dropWhile_0 0 (dropWhile_0-1 nil 3743183625 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitWhile_tr def-decl "[list[A], list[A]]" lem_list nil) (splitWhile const-decl "[list[A], list[A]]" lem_list nil) (dropWhile const-decl "list[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux dropWhile_1 0 (dropWhile_1-1 nil 3743183628 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitWhile_tr def-decl "[list[A], list[A]]" lem_list nil) (splitWhile const-decl "[list[A], list[A]]" lem_list nil) (dropWhile const-decl "list[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux dropWhile_2 0 (dropWhile_2-1 nil 3743183631 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitWhile_tr def-decl "[list[A], list[A]]" lem_list nil) (splitWhile const-decl "[list[A], list[A]]" lem_list nil) (dropWhile const-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux dropWhile_3 0 (dropWhile_3-1 nil 3743183634 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil) (list_cons const-decl "list[T]" list_extra nil) (splitWhile_tr def-decl "[list[A], list[A]]" lem_list nil) (splitWhile const-decl "[list[A], list[A]]" lem_list nil) (dropWhile const-decl "list[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux takeWhile_0 0 (takeWhile_0-1 nil 3743183636 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitWhile_tr def-decl "[list[A], list[A]]" lem_list nil) (splitWhile const-decl "[list[A], list[A]]" lem_list nil) (takeWhile const-decl "list[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux takeWhile_1 0 (takeWhile_1-1 nil 3743183640 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitWhile_tr def-decl "[list[A], list[A]]" lem_list nil) (splitWhile const-decl "[list[A], list[A]]" lem_list nil) (takeWhile const-decl "list[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux takeWhile_2 0 (takeWhile_2-1 nil 3743183643 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (splitWhile_tr def-decl "[list[A], list[A]]" lem_list nil) (splitWhile const-decl "[list[A], list[A]]" lem_list nil) (takeWhile const-decl "list[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux takeWhile_3 0 (takeWhile_3-1 nil 3743183646 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil) (list_cons const-decl "list[T]" list_extra nil) (splitWhile_tr def-decl "[list[A], list[A]]" lem_list nil) (splitWhile const-decl "[list[A], list[A]]" lem_list nil) (takeWhile const-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux isPrefixOf_0 0 (isPrefixOf_0-1 nil 3743183650 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (instance_Basic_classes_Eq_nat_dict const-decl "eq_class[nat]" lem_num nil) (isPrefixOf def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux isPrefixOf_1 0 (isPrefixOf_1-1 nil 3743183652 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (instance_Basic_classes_Eq_nat_dict const-decl "eq_class[nat]" lem_num nil) (isPrefixOf def-decl "bool" lem_list nil) (bool_and const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux isPrefixOf_2 0 (isPrefixOf_2-1 nil 3743183656 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (instance_Basic_classes_Eq_nat_dict const-decl "eq_class[nat]" lem_num nil) (isPrefixOf def-decl "bool" lem_list nil) (bool_and const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux isPrefixOf_3 0 (isPrefixOf_3-1 nil 3743183658 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (instance_Basic_classes_Eq_nat_dict const-decl "eq_class[nat]" lem_num nil) (isPrefixOf def-decl "bool" lem_list nil) (bool_and const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux isPrefixOf_4 0 (isPrefixOf_4-1 nil 3743183661 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (instance_Basic_classes_Eq_nat_dict const-decl "eq_class[nat]" lem_num nil) (isPrefixOf def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux list_update_1 0 (list_update_1-1 nil 3743183666 ("" (grind) nil nil) ((update def-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux list_update_2 0 (list_update_2-1 nil 3743183668 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (list_cons const-decl "list[T]" list_extra nil) (update def-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux list_update_3 0 (list_update_3-1 nil 3743183672 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (list_cons const-decl "list[T]" list_extra nil) (update def-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux list_update_4 0 (list_update_4-1 nil 3743183675 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (list_cons const-decl "list[T]" list_extra nil) (update def-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux list_update_5 0 (list_update_5-1 nil 3743183677 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (update def-decl "list[A]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux elem_1_TCC1 0 (elem_1_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (elem_1 subtype "list_adt[real].cons((1), list_adt[real].cons((2), list_adt[real].cons((4), list_adt[real].null)))" "list[nat]")))("lem_list_aux" lem_list_aux elem_1 0 (elem_1-1 nil 3743183682 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (instance_Basic_classes_Eq_nat_dict const-decl "eq_class[nat]" lem_num nil) (elem const-decl "[A -> [list[A] -> bool]]" lem_list nil) (some adt-def-decl "boolean" list_adt nil) (elemBy const-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux elem_2 0 (elem_2-1 nil 3743183684 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (instance_Basic_classes_Eq_nat_dict const-decl "eq_class[nat]" lem_num nil) (elem const-decl "[A -> [list[A] -> bool]]" lem_list nil) (some adt-def-decl "boolean" list_adt nil) (elemBy const-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux elem_3 0 (elem_3-1 nil 3743183686 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (instance_Basic_classes_Eq_nat_dict const-decl "eq_class[nat]" lem_num nil) (elem const-decl "[A -> [list[A] -> bool]]" lem_list nil) (some adt-def-decl "boolean" list_adt nil) (elemBy const-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux elem_4 0 (elem_4-1 nil 3743183689 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (instance_Basic_classes_Eq_nat_dict const-decl "eq_class[nat]" lem_num nil) (elem const-decl "[A -> [list[A] -> bool]]" lem_list nil) (some adt-def-decl "boolean" list_adt nil) (elemBy const-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux find_1 0 (find_1-1 nil 3743183692 ("" (grind) nil nil) ((find def-decl "option[A]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux find_2_TCC1 0 (find_2_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (find_2 subtype "list_adt[real].cons((1), list_adt[real].cons((3), list_adt[real].null))" "list[nat]")))("lem_list_aux" lem_list_aux find_2 0 (find_2-1 nil 3743183700 ("" (grind) nil nil) ((find def-decl "option[A]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux find_3_TCC1 0 (find_3_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (find_3 subtype "list_adt[real].cons((1), list_adt[real].cons((5), list_adt[real].cons((4), list_adt[real].null)))" "list[nat]")))("lem_list_aux" lem_list_aux find_3 0 (find_3-1 nil 3743183704 ("" (grind) nil nil) ((find def-decl "option[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux find_4_TCC1 0 (find_4_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (find_4 subtype "list_adt[real].cons((1), list_adt[real].cons((4), list_adt[real].cons((5), list_adt[real].cons((4), list_adt[real].null))))" "list[nat]")))("lem_list_aux" lem_list_aux find_4 0 (find_4-1 nil 3743183707 ("" (grind) nil nil) ((find def-decl "option[A]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux find_in 0 (find_in-1 nil 3743184039 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil) nil shostak))("lem_list_aux" lem_list_aux lookup_1_TCC1 0 (lookup_1_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (lookup_1 subtype "lem_list.lookupBy(lib_extra.eqs)((3))(list_adt[[real, real]].cons(((4), (5)), list_adt[[real, real]].cons(((3), (4)), list_adt[[real, real]].cons(((1), (2)), list_adt[[real, real]].cons(((3), (5)), list_adt[[real, real]].null)))))" "option[real]")))("lem_list_aux" lem_list_aux lookup_1 0 (lookup_1-1 nil 3743183710 ("" (grind) nil nil) ((map const-decl "[option[A] -> option[B]]" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (find def-decl "option[A]" lem_list nil) (maybe const-decl "B" lem_maybe nil) (lookupBy const-decl "option[B]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux lookup_2_TCC1 0 (lookup_2_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (lookup_2 subtype "lem_list.lookupBy(lib_extra.eqs)((8))(list_adt[[real, real]].cons(((4), (5)), list_adt[[real, real]].cons(((3), (4)), list_adt[[real, real]].cons(((1), (2)), list_adt[[real, real]].cons(((3), (5)), list_adt[[real, real]].null)))))" "option[nat]")))("lem_list_aux" lem_list_aux lookup_2 0 (lookup_2-1 nil 3743183712 ("" (grind) nil nil) ((map const-decl "[option[A] -> option[B]]" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (find def-decl "option[A]" lem_list nil) (maybe const-decl "B" lem_maybe nil) (lookupBy const-decl "option[B]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux lookup_3_TCC1 0 (lookup_3_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (lookup_3 subtype "lem_list.lookupBy(lib_extra.eqs)((1))(list_adt[[real, real]].cons(((4), (5)), list_adt[[real, real]].cons(((3), (4)), list_adt[[real, real]].cons(((1), (2)), list_adt[[real, real]].cons(((3), (5)), list_adt[[real, real]].null)))))" "option[real]")))("lem_list_aux" lem_list_aux lookup_3 0 (lookup_3-1 nil 3743183715 ("" (grind) nil nil) ((map const-decl "[option[A] -> option[B]]" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (find def-decl "option[A]" lem_list nil) (maybe const-decl "B" lem_maybe nil) (lookupBy const-decl "option[B]" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil)) shostak))("lem_list_aux" lem_list_aux filter_def_lemma 0 (filter_def_lemma-1 nil 3743183988 ("" (postpone) nil nil) nil shostak))("lem_list_aux" lem_list_aux filter_0 0 (filter_0-1 nil 3743183718 ("" (grind) nil nil) ((filter def-decl "list[T]" filters nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux filter_1_TCC1 0 (filter_1_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (filter_1 subtype "list_adt[real].cons((2), list_adt[real].cons((4), list_adt[real].cons((5), list_adt[real].cons((2), list_adt[real].cons((7), list_adt[real].cons((6), list_adt[real].null))))))" "list[nat]")))("lem_list_aux" lem_list_aux filter_1 0 (filter_1-1 nil 3743183720 ("" (grind) nil nil) ((filter def-decl "list[T]" filters nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux filter_nil_thm 0 (filter_nil_thm-1 nil 3743183951 ("" (grind) nil nil) ((filter def-decl "list[T]" filters nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux filter_cons_thm 0 (filter_cons_thm-1 nil 3743183958 ("" (induct "xs") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ((list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (list_cons const-decl "list[T]" list_extra nil) (filter def-decl "list[T]" filters nil) (pred type-eq-decl nil defined_types nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux partition_0 0 (partition_0-1 nil 3743183723 ("" (grind) nil nil) ((filter def-decl "list[T]" filters nil) (partition const-decl "[list[A], list[A]]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil) (pair_equal const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux partition_1_TCC1 0 (partition_1_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (partition_1 subtype "lem_list.partition((LAMBDA (x: naturalnumbers.nat): (reals.>(x, (4)))))(list_adt[nat].cons((1), list_adt[real].cons((2), list_adt[real].cons((4), list_adt[real].cons((5), list_adt[real].cons((2), list_adt[real].cons((7), list_adt[real].cons((6), list_adt[real].null))))))))" "[(list_adt[real].cons?), (list_adt[real].cons?)]")))("lem_list_aux" lem_list_aux partition_1 0 (partition_1-1 nil 3743183725 ("" (grind) nil nil) ((filter def-decl "list[T]" filters nil) (partition const-decl "[list[A], list[A]]" lem_list nil) (restrict const-decl "R" restrict nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (pair_equal const-decl "bool" lib_extra nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux partition_fst 0 (partition_fst-1 nil 3743183729 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (filter def-decl "list[T]" filters nil) (pred type-eq-decl nil defined_types nil) (partition const-decl "[list[A], list[A]]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux partition_snd 0 (partition_snd-1 nil 3743183746 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (NOT const-decl "[bool -> bool]" booleans nil) (filter def-decl "list[T]" filters nil) (pred type-eq-decl nil defined_types nil) (partition const-decl "[list[A], list[A]]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux deleteFirst_1_TCC1 0 (deleteFirst_1_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (deleteFirst_1 subtype "list_adt[real].cons((6), list_adt[real].cons((7), list_adt[real].cons((1), list_adt[real].null)))" "list[nat]")))("lem_list_aux" lem_list_aux deleteFirst_1 0 (deleteFirst_1-1 nil 3743183763 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (map const-decl "[option[A] -> option[B]]" lem_maybe nil) (list_delete_first def-decl "option[list[A]]" lem_list nil) (maybe const-decl "B" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux deleteFirst_2 0 (deleteFirst_2-1 nil 3743183766 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (map const-decl "[option[A] -> option[B]]" lem_maybe nil) (list_delete_first def-decl "option[list[A]]" lem_list nil) (maybe const-decl "B" lem_maybe nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux deleteFirst_3 0 (deleteFirst_3-1 nil 3743183769 ("" (grind) nil nil) ((list_delete_first def-decl "option[list[A]]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (maybeEqualBy const-decl "bool" lem_maybe nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak))("lem_list_aux" lem_list_aux delete_1 0 (delete_1-1 nil 3743183772 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (list_cons const-decl "list[T]" list_extra nil) (map const-decl "[option[A] -> option[B]]" lem_maybe nil) (list_delete_first def-decl "option[list[A]]" lem_list nil) (maybe const-decl "B" lem_maybe nil) (fromMaybe const-decl "A" lem_maybe nil) (list_delete const-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux delete_2 0 (delete_2-1 nil 3743183774 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (list_cons const-decl "list[T]" list_extra nil) (map const-decl "[option[A] -> option[B]]" lem_maybe nil) (list_delete_first def-decl "option[list[A]]" lem_list nil) (maybe const-decl "B" lem_maybe nil) (fromMaybe const-decl "A" lem_maybe nil) (list_delete const-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux delete_3 0 (delete_3-1 nil 3743183776 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (list_delete_first def-decl "option[list[A]]" lem_list nil) (fromMaybe const-decl "A" lem_maybe nil) (list_delete const-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux delete_4 0 (delete_4-1 nil 3743183779 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (list_delete_first def-decl "option[list[A]]" lem_list nil) (fromMaybe const-decl "A" lem_maybe nil) (list_delete const-decl "list[A]" lem_list nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux zip_1 0 (zip_1-1 nil 3743183782 ("" (grind) nil nil) ((list_combine def-decl "list[[A, B]]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (pair_equal const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux zip_2 0 (zip_2-1 nil 3743183784 ("" (grind) nil nil) ((list_combine def-decl "list[[A, B]]" lem_list nil) (list_cons const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (pair_equal const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_list_aux" lem_list_aux unzip_def_lemma 0 (unzip_def_lemma-1 nil 3743183873 ("" (postpone) nil nil) nil shostak))("lem_list_aux" lem_list_aux unzip_1 0 (unzip_1-1 nil 3743183787 ("" (grind) nil nil) ((split def-decl "[[list[A], list[B]]]" list_extra nil) (listEqualBy def-decl "bool" lem_list nil) (pair_equal const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux unzip_2_TCC1 0 (unzip_2_TCC1-1 nil 3743179080 ("" (subtype-tcc) nil nil) nil nil (unzip_2 subtype "list_extra.split(list_adt[[real, real]].cons(((1), (2)), list_adt[[real, real]].cons(((2), (3)), list_adt[[real, real]].cons(((3), (4)), list_adt[[real, real]].null))))" "[(list_adt[real].cons?), (list_adt[real].cons?)]")))("lem_list_aux" lem_list_aux unzip_2 0 (unzip_2-1 nil 3743183789 ("" (grind) nil nil) ((split def-decl "[[list[A], list[B]]]" list_extra nil) (restrict const-decl "R" restrict nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (pair_equal const-decl "bool" lib_extra nil)) shostak))("lem_either_aux" lem_either_aux either_1 0 (either_1-1 nil 3743188873 ("" (grind) nil nil) ((either const-decl "C" lem_either nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_either_aux" lem_either_aux either_2 0 (either_2-1 nil 3743188876 ("" (grind) nil nil) ((either const-decl "C" lem_either nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_either_aux" lem_either_aux either_3 0 (either_3-1 nil 3743188879 ("" (grind) nil nil) ((either const-decl "C" lem_either nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_either_aux" lem_either_aux either_4 0 (either_4-1 nil 3743188882 ("" (grind) nil nil) ((either const-decl "C" lem_either nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_either_aux" lem_either_aux partitionEither_1_TCC1 0 (partitionEither_1_TCC1-1 nil 3743186346 ("" (subtype-tcc) nil nil) nil nil (partitionEither_1 subtype "lem_either.partitionEither(list_adt[union_adt[booleans.boolean, booleans.boolean].union].cons(union_adt[booleans.boolean, booleans.boolean].inl(booleans.TRUE), list_adt[union_adt[booleans.boolean, booleans.boolean].union].cons(union_adt[booleans.boolean, booleans.boolean].inr(booleans.FALSE), list_adt[union_adt[booleans.boolean, booleans.boolean].union].cons(union_adt[booleans.boolean, booleans.boolean].inr(booleans.FALSE), list_adt[union_adt[booleans.boolean, booleans.boolean].union].cons(union_adt[booleans.boolean, booleans.boolean].inl(booleans.FALSE), list_adt[union_adt[booleans.boolean, booleans.boolean].union].cons(union_adt[booleans.boolean, booleans.boolean].inr(booleans.TRUE), list_adt[union_adt[booleans.boolean, booleans.boolean].union].null))))))" "[(list_adt[booleans.boolean].cons?), (list_adt[booleans.boolean].cons?)]")))("lem_either_aux" lem_either_aux partitionEither_1_TCC2 0 (partitionEither_1_TCC2-1 nil 3743186346 ("" (subtype-tcc) nil nil) nil nil (partitionEither_1 subtype "restrict[list_adt[booleans.boolean].list, (list_adt[booleans.boolean].cons?), [list_adt[booleans.boolean].list -> booleans.bool]].restrict(lem_list.listEqualBy(lib_extra.eqs))" "[(list_adt[booleans.boolean].cons?) -> [(list_adt[booleans.boolean].cons?) -> booleans.bool]]")))("lem_either_aux" lem_either_aux partitionEither_1 0 (partitionEither_1-1 nil 3743188884 ("" (grind) nil nil) ((partitionEither def-decl "[list[A], list[B]]" lem_either nil) (list_cons const-decl "list[T]" list_extra nil) (restrict const-decl "R" restrict nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil) (pair_equal const-decl "bool" lib_extra nil)) shostak))("lem_either_aux" lem_either_aux lefts_1 0 (lefts_1-1 nil 3743188888 ("" (grind) nil nil) ((partitionEither def-decl "[list[A], list[B]]" lem_either nil) (list_cons const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_either_aux" lem_either_aux rights_1 0 (rights_1-1 nil 3743188891 ("" (grind) nil nil) ((partitionEither def-decl "[list[A], list[B]]" lem_either nil) (list_cons const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (listEqualBy def-decl "bool" lem_list nil)) shostak))("lem_map_aux" lem_map_aux lookup_empty_TCC1 0 (lookup_empty_TCC1-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (lookup_empty existence "" "lem_map_aux.V")))("lem_map_aux" lem_map_aux lookup_empty_TCC2 0 (lookup_empty_TCC2-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (lookup_empty existence "" "lem_map_aux.V")))("lem_map_aux" lem_map_aux lookup_empty_TCC3 0 (lookup_empty_TCC3-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (lookup_empty existence "" "lem_map_aux.V")))("lem_map_aux" lem_map_aux lookup_insert_TCC1 0 (lookup_insert_TCC1-1 nil 3743437791 ("" (existence-tcc) nil nil) ((B decl-formal-type nil lem_map_aux nil)) nil (lookup_insert existence "" "lem_map_aux.B")))("lem_map_aux" lem_map_aux lookup_insert_TCC2 0 (lookup_insert_TCC2-1 nil 3743437791 ("" (existence-tcc) nil nil) ((B decl-formal-type nil lem_map_aux nil)) nil (lookup_insert existence "" "lem_map_aux.B")))("lem_map_aux" lem_map_aux lookup_insert_TCC3 0 (lookup_insert_TCC3-1 nil 3743437791 ("" (existence-tcc) nil nil) ((B decl-formal-type nil lem_map_aux nil) (eqs const-decl "bool" lib_extra nil)) nil (lookup_insert existence "" "lem_map_aux.B")))("lem_map_aux" lem_map_aux lookup_insert_TCC4 0 (lookup_insert_TCC4-1 nil 3743437791 ("" (existence-tcc) nil nil) ((B decl-formal-type nil lem_map_aux nil)) nil (lookup_insert existence "" "lem_map_aux.B")))("lem_map_aux" lem_map_aux lookup_insert_TCC5 0 (lookup_insert_TCC5-1 nil 3743437791 ("" (existence-tcc) nil nil) ((B decl-formal-type nil lem_map_aux nil)) nil (lookup_insert existence "" "lem_map_aux.B")))("lem_map_aux" lem_map_aux member_empty_TCC1 0 (member_empty_TCC1-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (member_empty existence "" "lem_map_aux.V")))("lem_map_aux" lem_map_aux member_empty_TCC2 0 (member_empty_TCC2-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (member_empty existence "" "lem_map_aux.V")))("lem_map_aux" lem_map_aux member_empty_TCC3 0 (member_empty_TCC3-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (member_empty existence "" "lem_map_aux.V")))("lem_map_aux" lem_map_aux member_insert_TCC1 0 (member_insert_TCC1-1 nil 3743437791 ("" (existence-tcc) nil nil) ((B decl-formal-type nil lem_map_aux nil)) nil (member_insert existence "" "lem_map_aux.B")))("lem_map_aux" lem_map_aux member_insert_TCC2 0 (member_insert_TCC2-1 nil 3743437791 ("" (existence-tcc) nil nil) ((B decl-formal-type nil lem_map_aux nil)) nil (member_insert existence "" "lem_map_aux.B")))("lem_map_aux" lem_map_aux member_insert_TCC3 0 (member_insert_TCC3-1 nil 3743437791 ("" (existence-tcc) nil nil) ((B decl-formal-type nil lem_map_aux nil)) nil (member_insert existence "" "lem_map_aux.B")))("lem_map_aux" lem_map_aux member_insert_TCC4 0 (member_insert_TCC4-1 nil 3743437791 ("" (existence-tcc) nil nil) ((B decl-formal-type nil lem_map_aux nil)) nil (member_insert existence "" "lem_map_aux.B")))("lem_map_aux" lem_map_aux member_insert_TCC5 0 (member_insert_TCC5-1 nil 3743437791 ("" (existence-tcc) nil nil) ((B decl-formal-type nil lem_map_aux nil)) nil (member_insert existence "" "lem_map_aux.B")))("lem_map_aux" lem_map_aux all_def_lemma_TCC1 0 (all_def_lemma_TCC1-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (all_def_lemma existence "" "lem_map_aux.V")))("lem_map_aux" lem_map_aux all_def_lemma_TCC2 0 (all_def_lemma_TCC2-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (all_def_lemma existence "" "lem_map_aux.V")))("lem_map_aux" lem_map_aux all_def_lemma_TCC3 0 (all_def_lemma_TCC3-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (all_def_lemma existence "" "lem_map_aux.V")))("lem_map_aux" lem_map_aux all_def_lemma_TCC4 0 (all_def_lemma_TCC4-1 nil 3743437791 ("" (existence-tcc) nil nil) ((V decl-formal-type nil lem_map_aux nil)) nil (all_def_lemma existence "" "lem_map_aux.V")))("word" word word_mod_TCC1 0 (word_mod_TCC1-1 nil 3742224061 ("" (skolem * ("w1" "w3") skolem-typepreds? T) (("" (use "mod_pos") (("" (grind) nil nil)) nil)) nil) ((mod_pos formula-decl nil mod nil) (nzword type-eq-decl nil word nil) (/= const-decl "boolean" notequal nil) (word type-eq-decl nil word nil) (N formal-const-decl "posnat" word nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (word_mod subtype "mod.mod(word.w1, word.w3)" "nat")))("lem_num_aux" lem_num_aux int32_test6_TCC1 0 (int32_test6_TCC1-1 nil 3742920976 ("" (grind) nil nil) ((nil application-judgement "above(n)" exp2 nil) (nil application-judgement "below(m)" mod nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (of_nat const-decl "word" word nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (exp2 def-decl "posnat" exp2 nil)) nil (int32_test6 subtype "word[32].of_nat(4)" "nzword[32]")))("lem_num_aux" lem_num_aux int64_test6_TCC1 0 (int64_test6_TCC1-1 nil 3742920976 ("" (grind) nil nil) ((nil application-judgement "above(n)" exp2 nil) (nil application-judgement "below(m)" mod nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (of_nat const-decl "word" word nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (exp2 def-decl "posnat" exp2 nil)) nil (int64_test6 subtype "word[64].of_nat(4)" "nzword[64]")))("list_extra" list_extra list_compare_TCC1 0 (list_compare_TCC1-1 nil 3744070646 ("" (termination-tcc) nil nil) nil nil (list_compare termination "list_extra.list_compare(list_extra.cmp)(list_extra.xs)(list_extra.ys)" "nil")))("lem_basic_classes_aux" lem_basic_classes_aux pairEqual_def_lemma 0 (pairEqual_def_lemma-1 nil 3742140372 ("" (grind) nil nil) ((bool_and const-decl "bool" lib_extra nil) (pair_equal const-decl "bool" lib_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_set_aux" lem_set_aux filter_1_TCC1 0 (filter_1_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil (filter_1 subtype "{x0: naturalnumbers.nat | booleans.OR(x0 = (1), booleans.OR(x0 = (2), booleans.OR(x0 = (3), x0 = (4))))}" "finite_set[nat]")))("lem_set_aux" lem_set_aux filter_insert_TCC1 0 (filter_insert_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil (filter_insert subtype "lem_set_aux.s" "finite_set[A]")))("lem_set_aux" lem_set_aux filter_insert_TCC2 0 (filter_insert_TCC2-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil (filter_insert subtype "lem_set_aux.s" "finite_set[A]")))("lem_set_aux" lem_set_aux filter_insert_TCC3 0 (filter_insert_TCC3-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil (filter_insert subtype "set_extra.add(lem_set_aux.e)(lem_set_aux.s)" "finite_set[A]")))("lem_set_aux" lem_set_aux split_simple_TCC1 0 (split_simple_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil (split_simple subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] |      (x0 = ((1), (0))) OR (x0 = ((2), (0))) OR (x0 = ((3), (0))) OR (x0 = ((4), (0))) OR (x0 = ((5), (0))) OR (x0 = ((6), (0)))}" "finite_set[[nat, nat]]")))("lem_set_aux" lem_set_aux cross_by_sigma_TCC1 0 (cross_by_sigma_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil (cross_by_sigma subtype "lem_set_aux.s2" "finite_set[B]")))("lem_set_aux" lem_set_aux cross_by_sigma_TCC2 0 (cross_by_sigma_TCC2-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil (cross_by_sigma subtype "lem_set_aux.s1" "finite_set[A]")))("lem_set_aux" lem_set_aux cross_1_TCC1 0 (cross_1_TCC1-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil (cross_1 subtype "{x1: booleans.bool | booleans.OR(x1, x1 = booleans.FALSE)}" "finite_set[boolean]")))("lem_set_aux" lem_set_aux cross_1_TCC2 0 (cross_1_TCC2-1 nil 3743265456 ("" (subtype-tcc) nil nil) nil nil (cross_1 subtype "{x0: naturalnumbers.nat | booleans.OR(x0 = (2), x0 = (3))}" "finite_set[nat]")))("lem_map_aux" lem_map_aux lookup_empty_TCC1 0 (lookup_empty_TCC1-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (lookup_empty existence "" "lem_map_aux.A")))("lem_map_aux" lem_map_aux lookup_empty_TCC2 0 (lookup_empty_TCC2-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (lookup_empty existence "" "lem_map_aux.A")))("lem_map_aux" lem_map_aux lookup_empty_TCC3 0 (lookup_empty_TCC3-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (lookup_empty existence "" "lem_map_aux.A")))("lem_relation_aux" lem_relation_aux rel_basic_0_TCC1 0 (rel_basic_0_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_basic_0 subtype "{x2: naturalnumbers.nat |      (x2 = (1)) OR (x2 = (2)) OR (x2 = (3)) OR (x2 = (4)) OR (x2 = (5)) OR (x2 = (6))}" "finite_set[nat]")))("lem_relation_aux" lem_relation_aux rel_basic_0_TCC2 0 (rel_basic_0_TCC2-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_basic_0 subtype "{x1: naturalnumbers.nat | booleans.OR(x1 = (2), x1 = (3))}" "finite_set[nat]")))("lem_relation_aux" lem_relation_aux inRel_pred_TCC1 0 (inRel_pred_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (inRel_pred subtype "lem_relation_aux.sb" "finite_set[A]")))("lem_relation_aux" lem_relation_aux inRel_pred_TCC2 0 (inRel_pred_TCC2-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (inRel_pred subtype "lem_relation_aux.sa" "finite_set[B]")))("lem_relation_aux" lem_relation_aux relId_spec_TCC1 0 (relId_spec_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (relId_spec subtype "lem_relation_aux.s" "finite_set[A]")))("lem_relation_aux" lem_relation_aux rel_id_0_TCC1 0 (rel_id_0_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_id_0 subtype "{x0: naturalnumbers.nat | booleans.OR(x0 = (0), booleans.OR(x0 = (1), booleans.OR(x0 = (2), x0 = (3))))}" "finite_set[nat]")))("lem_relation_aux" lem_relation_aux rel_comp_1_TCC1 0 (rel_comp_1_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_comp_1 subtype "lem_relation_aux.r2" "finite_set[[B, A]]")))("lem_relation_aux" lem_relation_aux rel_comp_1_TCC2 0 (rel_comp_1_TCC2-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_comp_1 subtype "lem_relation_aux.r1" "finite_set[[C, B]]")))("lem_relation_aux" lem_relation_aux rel_comp_3_TCC1 0 (rel_comp_3_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_comp_3 subtype "lem_relation_aux.r" "finite_set[[C, A]]")))("lem_relation_aux" lem_relation_aux rel_comp_3_TCC2 0 (rel_comp_3_TCC2-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_comp_3 subtype "lem_relation_aux.r" "finite_set[[C, A]]")))("lem_relation_aux" lem_relation_aux rel_comp_0_TCC1 0 (rel_comp_0_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_comp_0 subtype "{x1: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x1 = ((4), (3)), x1 = ((2), (8)))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux rel_comp_0_TCC2 0 (rel_comp_0_TCC2-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_comp_0 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((2), (4)), x0 = ((2), (8)))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux rel_restrict_0_TCC1 0 (rel_restrict_0_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_restrict_0 subtype "{x1: naturalnumbers.nat | booleans.OR(x1 = (2), x1 = (8))}" "finite_set[nat]")))("lem_relation_aux" lem_relation_aux rel_restrict_rel_empty_TCC1 0 (rel_restrict_rel_empty_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_restrict_rel_empty subtype "lem_relation_aux.s" "finite_set[A]")))("lem_relation_aux" lem_relation_aux rel_restrict_rel_add_TCC1 0 (rel_restrict_rel_add_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_restrict_rel_add subtype "lem_relation_aux.s" "finite_set[A]")))("lem_relation_aux" lem_relation_aux rel_restrict_rel_add_TCC2 0 (rel_restrict_rel_add_TCC2-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_restrict_rel_add subtype "lem_relation_aux.s" "finite_set[A]")))("lem_relation_aux" lem_relation_aux rel_restrict_rel_add_TCC3 0 (rel_restrict_rel_add_TCC3-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_restrict_rel_add subtype "lem_relation_aux.s" "finite_set[A]")))("lem_relation_aux" lem_relation_aux rel_apply_0_TCC1 0 (rel_apply_0_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_apply_0 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((2), (3)), booleans.OR(x0 = ((3), (4)), x0 = ((4), (5))))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux rel_apply_1_TCC1 0 (rel_apply_1_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_apply_1 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((2), (3)), booleans.OR(x0 = ((3), (7)), x0 = ((3), (5))))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux rel_apply_empty_set_TCC1 0 (rel_apply_empty_set_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_apply_empty_set subtype "lem_relation_aux.r" "finite_set[[B, A]]")))("lem_relation_aux" lem_relation_aux rel_apply_add_TCC1 0 (rel_apply_add_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_apply_add subtype "lem_relation_aux.r" "finite_set[[B, A]]")))("lem_relation_aux" lem_relation_aux rel_apply_add_TCC2 0 (rel_apply_add_TCC2-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_apply_add subtype "lem_relation_aux.r" "finite_set[[B, A]]")))("lem_relation_aux" lem_relation_aux rel_apply_add_TCC3 0 (rel_apply_add_TCC3-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (rel_apply_add subtype "set_extra.add(lem_relation_aux.x, lem_relation_aux.y)(lem_relation_aux.r)" "finite_set[[B, A]]")))("lem_relation_aux" lem_relation_aux is_transitive_0_TCC1 0 (is_transitive_0_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (is_transitive_0 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((2), (2)), booleans.OR(x0 = ((3), (3)), booleans.OR(x0 = ((3), (4)), x0 = ((4), (5)))))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux is_transitive_1_TCC1 0 (is_transitive_1_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (is_transitive_1 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((2), (3)), booleans.OR(x0 = ((3), (4)), x0 = ((2), (4))))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux is_single_valued_0_TCC1 0 (is_single_valued_0_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (is_single_valued_0 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((2), (3)), x0 = ((3), (4)))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux is_single_valued_1_TCC1 0 (is_single_valued_1_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (is_single_valued_1 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((2), (3)), booleans.OR(x0 = ((2), (4)), x0 = ((3), (4))))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux isStrictPartialOrderOn_antisym_TCC1 0 (isStrictPartialOrderOn_antisym_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (isStrictPartialOrderOn_antisym subtype "lem_relation_aux.r" "finite_set[[A, A]]")))("lem_relation_aux" lem_relation_aux is_strict_partialorder_on_0_TCC1 0 (is_strict_partialorder_on_0_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (is_strict_partialorder_on_0 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | x0 = ((2), (3))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux is_strict_partialorder_on_3_TCC1 0 (is_strict_partialorder_on_3_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (is_strict_partialorder_on_3 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((2), (3)), x0 = ((3), (2)))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux is_strict_partialorder_on_4_TCC1 0 (is_strict_partialorder_on_4_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (is_strict_partialorder_on_4 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((2), (3)), x0 = ((2), (2)))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux transitiveClosure_spec2_TCC1 0 (transitiveClosure_spec2_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (transitiveClosure_spec2 subtype "relations[lem_relation_aux.A].TC(lem_relation_aux.r)" "finite_set[[A, A]]")))("lem_relation_aux" lem_relation_aux transitiveClosure_spec3_TCC1 0 (transitiveClosure_spec3_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (transitiveClosure_spec3 subtype "lem_relation_aux.r2" "finite_set[[A, A]]")))("lem_relation_aux" lem_relation_aux transitiveClosure_spec4_TCC1 0 (transitiveClosure_spec4_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (transitiveClosure_spec4 subtype "lem_relation_aux.r" "finite_set[[A, A]]")))("lem_relation_aux" lem_relation_aux transitive_closure_add_thm_TCC1 0 (transitive_closure_add_thm_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (transitive_closure_add_thm subtype "lem_relation_aux.r" "finite_set[[A, A]]")))("lem_relation_aux" lem_relation_aux reflexive_transitive_closure_0_TCC1 0 (reflexive_transitive_closure_0_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (reflexive_transitive_closure_0 subtype "{x1: naturalnumbers.nat | booleans.OR(x1 = (2), booleans.OR(x1 = (3), x1 = (4)))}" "finite_set[nat]")))("lem_list_aux" lem_list_aux elem_1_TCC1 0 (elem_1_TCC1-1 nil 3743179080 ("" (grind) nil nil) ((every adt-def-decl "boolean" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (elem_1 subtype "list_adt[real].cons((1), list_adt[real].cons((2), list_adt[real].cons((4), list_adt[real].null)))" "list[nat]")))("lem_set_aux" lem_set_aux inmem_1 0 (inmem_1-1 nil 3743265612 ("" (grind) nil nil) ((extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (member const-decl "bool" set_extra nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_set_aux" lem_set_aux inmem_2 0 (inmem_2-1 nil 3743265616 ("" (grind) nil nil) ((extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (member const-decl "bool" set_extra nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_set_aux" lem_set_aux inmem_3 0 (inmem_3-1 nil 3743265619 ("" (grind) nil nil) ((emptyset const-decl "set" sets nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (member const-decl "bool" set_extra nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_extend application-judgement "finite_set[T]" extend_set_props nil) (finite_emptyset name-judgement "finite_set[T]" set_as_list "structures/") (finite_emptyset name-judgement "finite_set" finite_sets nil)) shostak))("lem_set_aux" lem_set_aux inmem_4 0 (inmem_4-1 nil 3743265621 ("" (grind) nil nil) ((extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (member const-decl "bool" set_extra nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak))("lem_map_aux" lem_map_aux empty_null_TCC1 0 (empty_null_TCC1-1 nil 3744128435 ("" (existence-tcc) nil nil) nil nil (empty_null existence "" "lem_map_aux.V")))("lem_map_aux" lem_map_aux lookup_empty_TCC1 0 (lookup_empty_TCC1-1 nil 3744140442 ("" (existence-tcc) nil nil) nil nil (lookup_empty existence "" "lem_map_aux.A")))("lem_map_aux" lem_map_aux lookup_empty_TCC2 0 (lookup_empty_TCC2-1 nil 3744140442 ("" (existence-tcc) nil nil) nil nil (lookup_empty existence "" "lem_map_aux.A")))("lem_map_aux" lem_map_aux lookup_empty_TCC3 0 (lookup_empty_TCC3-1 nil 3744140442 ("" (existence-tcc) nil nil) nil nil (lookup_empty existence "" "lem_map_aux.A")))("lem_map_aux" lem_map_aux lookup_insert_TCC3 0 (lookup_insert_TCC3-1 nil 3743437791 ("" (existence-tcc) nil nil) ((B decl-formal-type nil lem_map_aux nil)) nil (lookup_insert existence "" "lem_map_aux.B")))("lem_map_aux" lem_map_aux member_empty_TCC1 0 (member_empty_TCC1-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (member_empty existence "" "lem_map_aux.A")))("lem_map_aux" lem_map_aux member_empty_TCC2 0 (member_empty_TCC2-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (member_empty existence "" "lem_map_aux.A")))("lem_map_aux" lem_map_aux member_empty_TCC3 0 (member_empty_TCC3-1 nil 3743437791 ("" (existence-tcc) nil nil) nil nil (member_empty existence "" "lem_map_aux.A")))("lem_relation_aux" lem_relation_aux trancl_withoutTransitiveEdges_thm_TCC1 0 (trancl_withoutTransitiveEdges_thm_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (trancl_withoutTransitiveEdges_thm subtype "lem_relation_aux.r" "finite_set[[A, A]]")))("lem_relation_aux" lem_relation_aux withoutTransitiveEdges_0_TCC1 0 (withoutTransitiveEdges_0_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (withoutTransitiveEdges_0 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | x0 = ((0), (1))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux withoutTransitiveEdges_1_TCC1 0 (withoutTransitiveEdges_1_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (withoutTransitiveEdges_1 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((0), (1)), booleans.OR(x0 = ((1), (2)), x0 = ((0), (2))))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux withoutTransitiveEdges_2_TCC1 0 (withoutTransitiveEdges_2_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (withoutTransitiveEdges_2 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((0), (1)), booleans.OR(x0 = ((1), (2)), booleans.OR(x0 = ((2), (3)), x0 = ((0), (3)))))}" "finite_set[[nat, nat]]")))("lem_relation_aux" lem_relation_aux withoutTransitiveEdges_3_TCC1 0 (withoutTransitiveEdges_3_TCC1-1 nil 3743969142 ("" (subtype-tcc) nil nil) nil nil (withoutTransitiveEdges_3 subtype "{x0: [naturalnumbers.nat, naturalnumbers.nat] | booleans.OR(x0 = ((0), (0)), x0 = ((0), (1)))}" "finite_set[[nat, nat]]")))("lem_list_aux" lem_list_aux splitAt_1_TCC1 0 (splitAt_1_TCC1-1 nil 3743179080 ("" (grind) nil nil) ((every adt-def-decl "boolean" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (splitAt_1 subtype "list_adt[real].cons((2), list_adt[real].cons((3), list_adt[real].cons((4), list_adt[real].cons((5), list_adt[real].cons((6), list_adt[real].null)))))" "list[nat]")))("lem_list_aux" lem_list_aux length_def_lemma 0 (length_def_lemma-1 nil 3743179307 ("" (grind) nil nil) ((length def-decl "nat" list_props nil) (eqs const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux length_spec 0 (length_spec-1 nil 3743179327 ("" (grind) nil nil) ((length def-decl "nat" list_props nil) (eqs const-decl "bool" lib_extra nil) (list_cons const-decl "list[T]" list_extra nil) (bool_and const-decl "bool" lib_extra nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak))("lem_list_aux" lem_list_aux append_def_lemma 0 (append_def_lemma-1 nil 3743179408 ("" (induct "xs") (("1" (induct "ys") (("1" (grind) nil nil) ("2" (expand "listEqualBy") (("2" (grind) (("2" (expand "listEqualBy") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ((append def-decl "list[T]" list_props nil) (list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (list_append const-decl "list[T]" list_extra nil) (list_cons const-decl "list[T]" list_extra nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (eqs const-decl "bool" lib_extra nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux snoc_def_lemma 0 (snoc_def_lemma-1 nil 3743181556 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((append def-decl "list[T]" list_props nil) (list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_append const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux snoc_length 0 (snoc_length-1 nil 3743181589 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (append def-decl "list[T]" list_props nil) (list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (succ const-decl "nat" naturalnumbers nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_append const-decl "list[T]" list_extra nil) (length def-decl "nat" list_props nil) (eqs const-decl "bool" lib_extra nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux snoc_append 0 (snoc_append-1 nil 3743181609 ("" (induct "l1") (("1" (induct "l2") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ((append def-decl "list[T]" list_props nil) (list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_append const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (list_equal_by def-decl "bool" list_extra nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux reverse_def_lemma 0 (reverse_def_lemma-1 nil 3743181658 ("" (induct "l") (("1" (grind) nil nil) ("2" (induct "cons2_var") (("1" (grind) nil nil) ("2" (postpone) nil nil)) nil)) nil) nil shostak))("lem_list_aux" lem_list_aux reverse_nil 0 (reverse_nil-1 nil 3743182154 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil) (list_equal_by def-decl "bool" list_extra nil)) shostak))("lem_list_aux" lem_list_aux reverseAppend 0 (reverseAppend-1 nil 3743182875 ("" (induct "l1") (("1" (induct "l2") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) (("2" (postpone) nil nil)) nil)) nil) nil shostak))("lem_list_aux" lem_list_aux map_def_lemma 0 (map_def_lemma-1 nil 3743182914 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) (("2" (postpone) nil nil)) nil)) nil) nil shostak))("lem_list_aux" lem_list_aux map_nil 0 (map_nil-1 nil 3743182944 ("" (grind) nil nil) ((map adt-def-decl "list[T1]" list_adt_map nil) (list_equal_by def-decl "bool" list_extra nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak))("lem_list_aux" lem_list_aux concat_nil 0 (concat_nil-1 nil 3743183120 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (foldr def-decl "B" list_extra nil) (list_equal_by def-decl "bool" list_extra nil)) shostak))("lem_list_aux" lem_list_aux concat_emp_thm 0 (concat_emp_thm-1 nil 3743183140 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (foldr def-decl "B" list_extra nil) (list_equal_by def-decl "bool" list_extra nil)) shostak))("lem_list_aux" lem_list_aux concatMap_nil 0 (concatMap_nil-1 nil 3743183178 ("" (grind) nil nil) ((concat const-decl "[list[list[A]] -> list[A]]" lem_list nil) (map adt-def-decl "list[T1]" list_adt_map nil) (foldr def-decl "B" list_extra nil) (list_equal_by def-decl "bool" list_extra nil)) shostak))("lem_list_aux" lem_list_aux concatMap_alt_def 0 (concatMap_alt_def-1 nil 3743445813 ("" (induct "l") (("1" (skeep) (("1" (grind) nil nil)) nil) ("2" (skolem * ("x" "xs")) (("2" (prop) (("2" (grind) (("2" (expand "foldr") (("2" (grind) (("1" (grind) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("lem_list_aux" lem_list_aux dest_init_nil 0 (dest_init_nil-1 nil 3743183299 ("" (grind) nil nil) ((dest_init const-decl "option[[list[A], A]]" lem_list nil) (option_equal const-decl "bool" lib_extra nil)) shostak))("lem_list_aux" lem_list_aux index_is_none 0 (index_is_none-1 nil 3743183386 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (n!1 skolem-const-decl "nat" lem_list_aux nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (length def-decl "nat" list_props nil) (None adt-constructor-decl "(None?)" option_adt nil) (None? adt-recognizer-decl "[option -> boolean]" option_adt nil) (index def-decl "option[A]" lem_list nil) (option_equal const-decl "bool" lib_extra nil) (option type-decl nil option_adt nil) (eqs const-decl "bool" lib_extra nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux elemBy_def_lemma 0 (elemBy_def_lemma-1 nil 3744479788 ("" (grind) (("1" (expand "list_member_by") (("1" (grind) (("1" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil) nil shostak))("lem_list_aux" lem_list_aux filter_nil_thm 0 (filter_nil_thm-1 nil 3743183951 ("" (grind) nil nil) ((filter def-decl "list[T]" filters nil) (list_equal_by def-decl "bool" list_extra nil)) shostak))("lem_list_aux" lem_list_aux filter_cons_thm 0 (filter_cons_thm-1 nil 3743183958 ("" (induct "xs") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ((list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (list_cons const-decl "list[T]" list_extra nil) (filter def-decl "list[T]" filters nil) (pred type-eq-decl nil defined_types nil) (eqs const-decl "bool" lib_extra nil) (list_equal_by def-decl "bool" list_extra nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux partition_fst 0 (partition_fst-1 nil 3743183729 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (filter def-decl "list[T]" filters nil) (pred type-eq-decl nil defined_types nil) (partition const-decl "[list[A], list[A]]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (list_equal_by def-decl "bool" list_extra nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux partition_snd 0 (partition_snd-1 nil 3743183746 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (NOT const-decl "[bool -> bool]" booleans nil) (filter def-decl "list[T]" filters nil) (pred type-eq-decl nil defined_types nil) (partition const-decl "[list[A], list[A]]" lem_list nil) (eqs const-decl "bool" lib_extra nil) (list_equal_by def-decl "bool" list_extra nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux unzip_def_lemma 0 (unzip_def_lemma-1 nil 3743183873 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem + ("x" "xs")) (("3" (prop) (("3" (grind) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (A decl-formal-type nil lem_list_aux nil) (B decl-formal-type nil lem_list_aux nil) (split def-decl "[[list[A], list[B]]]" list_extra nil) (list_cons const-decl "list[T]" list_extra nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (eqs const-decl "bool" lib_extra nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("lem_list_aux" lem_list_aux allDistinct_def_lemma 0 (allDistinct_def_lemma-1 nil 3744479778 ("" (grind) nil nil) ((bool_and const-decl "bool" lib_extra nil) (list_member const-decl "bool" list_extra nil) (distinct def-decl "bool" list_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms wordFromBitlist_test_TCC1 0 (wordFromBitlist_test_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (wordFromBitlist_test subtype "list_adt[booleans.boolean].cons(booleans.FALSE, list_adt[booleans.boolean].cons(booleans.FALSE, list_adt[booleans.boolean].cons(booleans.TRUE, list_adt[booleans.boolean].cons(booleans.FALSE, list_adt[booleans.boolean].null))))" "{l: list_adt[booleans.boolean].list | reals.>(list_props[booleans.boolean].length(l), 0)}")))("thms" thms wordFromBitlist_bitListFromWord_test_TCC1 0 (wordFromBitlist_bitListFromWord_test_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (wordFromBitlist_bitListFromWord_test subtype "mword.word_to_bl(thms.w)" "{l: list_adt[booleans.boolean].list | reals.>(list_props[booleans.boolean].length(l), 0)}")))("thms" thms extract_concat_test_TCC1 0 (extract_concat_test_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (wordFromNatural const-decl "mword" lem_machine_word nil) (word_inject const-decl "mword" mword nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (instance_Machine_word_Size_Machine_word_ty16_dict const-decl "size_class[ty16]" lem_machine_word nil) (nil application-judgement "above(n)" exp2 nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil (extract_concat_test subtype "thms.x" "{nw: mword.mword | reals.>(nw`1, (3))}")))("thms" thms extract_concat_test_TCC2 0 (extract_concat_test_TCC2-1 nil 3745008557 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (wordFromNatural const-decl "mword" lem_machine_word nil) (word_inject const-decl "mword" mword nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (instance_Machine_word_Size_Machine_word_ty16_dict const-decl "size_class[ty16]" lem_machine_word nil) (nil application-judgement "above(n)" exp2 nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil (extract_concat_test subtype "thms.x" "{nw: mword.mword | reals.>(nw`1, (10))}")))("thms" thms extract_concat_test_TCC3 0 (extract_concat_test_TCC3-1 nil 3745008557 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (wordFromNatural const-decl "mword" lem_machine_word nil) (word_inject const-decl "mword" mword nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (instance_Machine_word_Size_Machine_word_ty16_dict const-decl "size_class[ty16]" lem_machine_word nil) (nil application-judgement "above(n)" exp2 nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil (extract_concat_test subtype "thms.x" "{nw: mword.mword | reals.>(nw`1, (15))}")))("thms" thms update_test_TCC1 0 (update_test_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) ((posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (instance_Machine_word_Size_Machine_word_ty16_dict const-decl "size_class[ty16]" lem_machine_word nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (word_inject const-decl "mword" mword nil) (wordFromNatural const-decl "mword" lem_machine_word nil) (instance_Machine_word_Size_Machine_word_ty8_dict const-decl "size_class[ty8]" lem_machine_word nil) (nil application-judgement "above(n)" exp2 nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil (update_test subtype "thms.y" "{nw: mword.mword | nw`1 = (8)}")))("thms" thms update_test_TCC2 0 (update_test_TCC2-1 nil 3745008557 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (instance_Machine_word_Size_Machine_word_ty16_dict const-decl "size_class[ty16]" lem_machine_word nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (word_inject const-decl "mword" mword nil) (wordFromNatural const-decl "mword" lem_machine_word nil) (instance_Machine_word_Size_Machine_word_ty8_dict const-decl "size_class[ty8]" lem_machine_word nil) (nil application-judgement "above(n)" exp2 nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil (update_test subtype "(1)" "naturalnumbers.below(thms.x`1)")))("thms" thms getBit_test_TCC1 0 (getBit_test_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (nil application-judgement "below(m)" mod nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (wordFromNatural const-decl "mword" lem_machine_word nil) (word_inject const-decl "mword" mword nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (instance_Machine_word_Size_Machine_word_ty8_dict const-decl "size_class[ty8]" lem_machine_word nil)) nil (getBit_test subtype "(1)" "naturalnumbers.below(lem_machine_word.wordFromNatural[ty8](lem_machine_word.instance_Machine_word_Size_Machine_word_ty8_dict)((3))`1)")))("thms" thms pairEqual_def_lemma 0 (pairEqual_def_lemma-1 nil 3745009166 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (bool_and const-decl "bool" lib_extra nil) (pair_equal const-decl "bool" lib_extra nil)) shostak))("thms" thms id_def_lemma 0 (id_def_lemma-1 nil 3745009174 ("" (grind) nil nil) ((id const-decl "(bijective?[T, T])" identity nil) (eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms apply_def_lemma 0 (apply_def_lemma-1 nil 3745009187 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms maybeEqualBy_def_lemma 0 (maybeEqualBy_def_lemma-1 nil 3745009192 ("" (grind) nil nil) ((option_equal const-decl "bool" lib_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms isJustNothing 0 (isJustNothing-1 nil 3745009197 ("" (grind) nil nil) ((isNothing const-decl "bool" lem_maybe nil) (isJust const-decl "bool" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (bool_and const-decl "bool" lib_extra nil)) shostak))("thms" thms fromMaybe 0 (fromMaybe-1 nil 3745009203 ("" (grind) nil nil) ((fromMaybe const-decl "A" lem_maybe nil) (eqs const-decl "bool" lib_extra nil) (bool_and const-decl "bool" lib_extra nil)) shostak))("thms" thms maybe_map 0 (maybe_map-1 nil 3745009209 ("" (grind) nil nil) ((map const-decl "[option[A] -> option[B]]" lem_maybe nil) (maybe const-decl "B" lem_maybe nil) (option_equal const-decl "bool" lib_extra nil) (eqs const-decl "bool" lib_extra nil) (bool_and const-decl "bool" lib_extra nil)) shostak))("thms" thms maybe_bind 0 (maybe_bind-1 nil 3745009214 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (maybe const-decl "B" lem_maybe nil) (bind const-decl "option[B]" lem_maybe nil) (option_equal const-decl "bool" lib_extra nil) (bool_and const-decl "bool" lib_extra nil)) shostak))("thms" thms natSucc_def_lemma 0 (natSucc_def_lemma-1 nil 3745009218 ("" (grind) nil nil) ((succ const-decl "nat" naturalnumbers nil) (eqs const-decl "bool" lib_extra nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak))("thms" thms naturalSucc_def_lemma 0 (naturalSucc_def_lemma-1 nil 3745009223 ("" (grind) nil nil) ((succ const-decl "nat" naturalnumbers nil) (eqs const-decl "bool" lib_extra nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak))("thms" thms rationalPowNat_def_lemma_TCC1 0 (rationalPowNat_def_lemma_TCC1-1 nil 3745008557 ("" (grind) nil nil) ((/= const-decl "boolean" notequal nil)) nil (rationalPowNat_def_lemma subtype "thms.e" "{i: integers.int | booleans.OR(thms.r /= 0, reals.>=(i, 0))}")))("thms" thms rationalPowNat_def_lemma 0 (rationalPowNat_def_lemma-1 nil 3745009241 ("" (induct "e") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_expt application-judgement "rat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (expt def-decl "real" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (rationalPowInteger def-decl "rat" lem_num nil) (eqs const-decl "bool" lib_extra nil) (rat nonempty-type-eq-decl nil rationals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak))("thms" thms realPowNat_def_lemma_TCC1 0 (realPowNat_def_lemma_TCC1-1 nil 3745008557 ("" (grind) nil nil) ((/= const-decl "boolean" notequal nil)) nil (realPowNat_def_lemma subtype "thms.e" "{i: integers.int | booleans.OR(thms.r /= 0, reals.>=(i, 0))}")))("thms" thms realPowNat_def_lemma 0 (realPowNat_def_lemma-1 nil 3745009413 ("" (induct "e") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (expt def-decl "real" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (realPowInteger def-decl "real" lem_num nil) (eqs const-decl "bool" lib_extra nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak))("thms" thms fst_def_lemma 0 (fst_def_lemma-1 nil 3745009424 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms snd_def_lemma 0 (snd_def_lemma-1 nil 3745009428 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms fst_snd 0 (fst_snd-1 nil 3745009432 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (pair_equal const-decl "bool" lib_extra nil)) shostak))("thms" thms curry_uncurry 0 (curry_uncurry-1 nil 3745009436 ("" (grind) nil nil) ((curry const-decl "[A -> [B -> C]]" lem_function nil) (uncurry const-decl "C" lem_function nil) (eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms uncurry_curry 0 (uncurry_curry-1 nil 3745009440 ("" (grind) nil nil) ((uncurry const-decl "C" lem_function nil) (curry const-decl "[A -> [B -> C]]" lem_function nil) (eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms swap_def_lemma 0 (swap_def_lemma-1 nil 3745009443 ("" (grind) nil nil) ((eqs const-decl "bool" lib_extra nil) (pair_equal const-decl "bool" lib_extra nil)) shostak))("thms" thms length_def_lemma 0 (length_def_lemma-1 nil 3745009447 ("" (grind) nil nil) ((length def-decl "nat" list_props nil) (eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms length_spec 0 (length_spec-1 nil 3745009451 ("" (grind) nil nil) ((length def-decl "nat" list_props nil) (eqs const-decl "bool" lib_extra nil) (list_cons const-decl "list[T]" list_extra nil) (bool_and const-decl "bool" lib_extra nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak))("thms" thms listEqualBy_def_lemma 0 (listEqualBy_def_lemma-1 nil 3745009454 ("" (grind) nil nil) ((bool_and const-decl "bool" lib_extra nil) (list_equal_by def-decl "bool" list_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms lexicographicCompareBy_def_lemma 0 (lexicographicCompareBy_def_lemma-1 nil 3745009461 ("" (grind) nil nil) ((list_compare_by def-decl "ordering" list_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms append_def_lemma 0 (append_def_lemma-1 nil 3745009467 ("" (grind) nil nil) ((list_cons const-decl "list[T]" list_extra nil) (append def-decl "list[T]" list_props nil) (list_append const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms snoc_def_lemma 0 (snoc_def_lemma-1 nil 3745009473 ("" (grind) nil nil) ((list_append const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms snoc_length 0 (snoc_length-1 nil 3745009476 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (append def-decl "list[T]" list_props nil) (list_induction formula-decl nil list_adt nil) (A decl-formal-type nil thms nil) (succ const-decl "nat" naturalnumbers nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_append const-decl "list[T]" list_extra nil) (length def-decl "nat" list_props nil) (eqs const-decl "bool" lib_extra nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("thms" thms snoc_append 0 (snoc_append-1 nil 3745009508 ("" (induct "l1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((append def-decl "list[T]" list_props nil) (list_induction formula-decl nil list_adt nil) (A decl-formal-type nil thms nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_append const-decl "list[T]" list_extra nil) (eqs const-decl "bool" lib_extra nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak))("thms" thms reverse_def_lemma 0 (reverse_def_lemma-1 nil 3745019543 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) (("2" (expand "reverseAppend" +) (("2" (case "cons2_var!1 = null") (("1" (assert) nil nil) ("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("thms" thms reverse_nil 0 (reverse_nil-1 nil 3745020753 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil) (eqs const-decl "bool" lib_extra nil)) shostak))("thms" thms reverseAppend 0 (reverseAppend-1 nil 3745020761 ("" (postpone) nil nil) nil shostak))("thms" thms map_def_lemma 0 (map_def_lemma-1 nil 3745020768 ("" (grind) (("" (expand "count_map") (("" (grind) (("" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("thms" thms any_def_lemma 0 (any_def_lemma-1 nil 3745032014 ("" (induct "l") (("1" (grind) nil nil) ("2" (postpone) nil nil)) nil) nil shostak))("thms" thms null_size_TCC1 0 (null_size_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (null_size subtype "(0)" "{n: naturalnumbers.nat | n = finite_sets[thms.A].Card(thms.s)}")))("thms" thms null_size_TCC2 0 (null_size_TCC2-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (null_size subtype "thms.s" "finite_set[A]")))("thms" thms null_size_TCC3 0 (null_size_TCC3-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (null_size subtype "thms.s" "finite_set[A]")))("thms" thms null_singleton_TCC1 0 (null_singleton_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (null_singleton subtype "(1)" "{n: naturalnumbers.nat | n = finite_sets[thms.A].Card(sets[thms.A].singleton(thms.x))}")))("thms" thms set_filter_def_lemma_TCC1 0 (set_filter_def_lemma_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (set_filter_def_lemma subtype "thms.s" "finite_set[A]")))("thms" thms bigunion_def_lemma_TCC1 0 (bigunion_def_lemma_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (bigunion_def_lemma subtype "thms.bs" "finite_set[set[A]]")))("thms" thms bigunion_def_lemma_TCC2 0 (bigunion_def_lemma_TCC2-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (bigunion_def_lemma subtype "thms.s" "finite_set[A]")))("thms" thms bigintersection_def_lemma_TCC1 0 (bigintersection_def_lemma_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (bigintersection_def_lemma subtype "set_extra.bigunion(thms.bs)" "finite_set[A]")))("thms" thms set_map_def_lemma_TCC1 0 (set_map_def_lemma_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (set_map_def_lemma subtype "thms.s" "finite_set[A]")))("thms" thms sigma_def_lemma_TCC1 0 (sigma_def_lemma_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (sigma_def_lemma subtype "thms.sa" "finite_set[A]")))("thms" thms sigma_def_lemma_TCC2 0 (sigma_def_lemma_TCC2-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (sigma_def_lemma subtype "thms.sb(thms.a)" "finite_set[B]")))("thms" thms cross_def_lemma_TCC1 0 (cross_def_lemma_TCC1-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (cross_def_lemma subtype "thms.s1" "finite_set[A]")))("thms" thms cross_def_lemma_TCC2 0 (cross_def_lemma_TCC2-1 nil 3745008557 ("" (subtype-tcc) nil nil) nil nil (cross_def_lemma subtype "thms.s2" "finite_set[B]")))