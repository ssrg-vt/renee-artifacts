#!/usr/bin/env python
#!/usr/bin/env python
# Run the script using python test_lemma_generator_pvscontrolled.py <<ASL_inst.xml>> <<ASL_inst_class_name>> <<0x01>> <<0x02>> <<0x03>>
# For example, python test_lemma_generator_pvs_controlled.py subs_addsub_shift.xml addsub_shift 0x01 0x02 0x03

import xml.etree.ElementTree as ET
import sys
import json

import re
import os
import os.path as path
import pickle
import master_test_controlled as mtest
import test_concrete as tc


class pvs_lemma_generator:
	
	# Initializes variables for pvs_lemma_generator, input registers, output registers, bitstrings which are randomly generated by the master_test modul
	def __init__(self,pvs_filename):
		self.pvs_lemma_filename = pvs_filename
		self.name_inputfile =  ""		
		self.f = open ( pvs_lemma_filename + ".pvs" , "w")
		self.input_bitstring = ""
		self.hexstring = ""
		self.Rd = ""
		self.Rn = ""
		self.Rm = ""
		# These store the initial values when running the instruction on Unicorn
		self.Rd_val = []
		self.Rm_val = []
		self.Rn_val = []	
		self.R_NZCV = []
		self.R_PC = []
		
		# This stores the register number of the output register in Unicorn
		self.R_op = ""		
		self.R_op_val = ""	
			              
        # This generates the PVS lemma file for the corresponding Unicorn output file for a randomly generated instruction that respects the instruction format
	def generate_pvs_lemma_file(self):		
		self.f.write (self.pvs_lemma_filename )
		self.f.write ("      : THEORY")
		self.f.write ("\n      BEGIN")
		self.f.write ("\n      IMPORTING arm_state")
		self.f.write ( "\n      X_sts : [ below(32) -> bvec[64] ]  = init`X  with [("+self.Rd+"):= "  +  self.Rd_val[0] + "," + "\n\t\t\t\t\t\t\t ("+self.Rm +"):= " + self.Rm_val[0] + ","  +  "\n\t\t\t\t\t\t\t (" +self.Rn+"):= "  +  self.Rn_val[0] + "] \n")		                                         
		self.f.write ( "\n      p1    :  s = init with [`X:= X_sts, `NZVC:= " +self.R_NZCV[0]  + "," "`PC:= " +  self.R_PC[0] +   "]")  
		self.f.write ( "\n      importing concrete_test_subsaddsubshift_" + self.hexstring.upper() + "[p1]{{Diag:= " + self.input_bitstring +", addr:= " + self.R_PC[0] + "}}\n")        
		self.f.write ( "\n      test1: lemma let X_post =  p1`X with [ ( "+ self.R_op + " ) " + ":= " + self.R_op_val+ "] in\n")
		self.f.write ( "\n          let p2     =  p1 with [`X:= X_post, `NZVC:=" + self.R_NZCV[0], + "`PC:= " + self.R_PC[1] + "] in\n")   
		self.f.write ( "\n          concrete_test_subsaddsubshift_"+ self.hexstring.upper() +"[p1].post`X(" + self.R_op +") = p2`X("+ self.R_op + ")\n")
		self.f.write ("\n%|- test1 : PROOF  (test-subs-addsub-shift " + self.R_op +")  ")
		self.f.write ("\n%|- QED")
		self.f.write ( "\nEND " + self.pvs_lemma_filename)

	# This method sets the filename for the unicorn_output_file which is the input file for this program to generate the pvs test lemma file
	def set_name_inputfile (self, filename):
		self.name_inputfile = filename

	# This method reads from the output file generated by Unicorn for an instruction simulation to extract the parameter values ofr pvs lemma file
	def parse_unicorn_output_file(self):
		try:
		   output_dir = "unicorn_outputs/"
		   output_file_ptr = open ( output_dir + self.name_inputfile , "r")
		   print "Opening file " + self.name_inputfile	
		   for line in output_file_ptr:
			line = line.strip()
			if "=" in line:
				tokens = line.split("=")
				if tokens [0] == "input_bitstring":
					self.input_bitstring = tokens[1]
				elif tokens [0] == "input_hexstring":	
					print "SET"				
					self.input_hexstring = tokens[1]
				elif tokens[0] == "Rd":
					self.Rd = tokens[1]
				elif tokens[0] == "Rm":
					self.Rm = tokens[1]
				elif tokens[0] == "Rn":
					self.Rn = tokens[1]
				elif tokens[0] == "Rd_pre":
					self.Rd_val.append (tokens[1])
				elif tokens[0] == "Rm_pre":
					self.Rm_val.append (tokens[1])
				elif tokens[0] == "Rn_pre":
					self.Rn_val.append (tokens[1])
				elif tokens[0] == "R_PC_pre":
					self.R_PC.append (tokens[1])
				elif tokens[0] == "R_NZCV_pre":
					self.R_NZCV.append (tokens[1])
				elif tokens[0] == "Rd_post":
					self.Rd_val.append (tokens[1])
				elif tokens[0] == "Rm_post":
					self.Rm_val.append (tokens[1])
				elif tokens[0] == "Rn_post":
					self.Rn_val.append (tokens[1])
				elif tokens[0] == "R_PC_post":
					self.R_PC.append (tokens[1])
				elif tokens[0] == "R_NZCV_post":
					self.R_NZCV.append (tokens[1])
				elif tokens[0] == "R_op":
					self.R_op = tokens[1]
				elif tokens[0] == "R_op_val":
					self.R_op_val = tokens[1]
	        except IOError:
		      print "Error: File does not appear to exist."
		      return 0


if __name__ == '__main__':
	# argv[1] is the name of the instruction which needs to be randomly generated and tested
	inst_filename = sys.argv[1]
	Rd_u = sys.argv[3]
	Rm_u = sys.argv[4]
	Rn_u = sys.argv[5]
	# Remove the ".xml" from the arg to get the instruction name
	inst_name = inst_filename.replace (".xml","")
	# Create an object of the inst_generator class		
	inst_test_suite = mtest.inst_generator(inst_filename)
	# Extracts the diagram format from ASL for each instruction which is provided in the command line as an argument 
	inst_test_suite.extract_fields()
	# Generates a txt file with field names about the random bitstring generated for a particular ARM inst				
	inst_test_suite.generate_validation_file()
	# Extract registers from the previous output
	reg_list = inst_test_suite.get_registers()
	# Fixes the bytestring issue in unicorn for the test genration
	int_list = inst_test_suite.get_bytestr()
	bytecode = bytearray(int_list)
	# Unicorn output file
	unicorn_output_file_name = inst_test_suite.get_hexstring()
	hexstring = unicorn_output_file_name
	output_dir = "unicorn_outputs/"
	op_fileptr = open( output_dir + unicorn_output_file_name,"w")
	bitstring = inst_test_suite.get_pvs_bitstring()
	op_fileptr.write("input_bitstring=" + bitstring  +"\n")
	op_fileptr.write("input_hexstring=" + hexstring  +"\n")
	# Run the instruction 
	mtest.test_arm64(bytes(bytecode), op_fileptr, reg_list, Rd_u, Rm_u, Rn_u)

	# Code for generating the pvs lemma file from the unicorn output file
	pvs_lemma_filename = inst_name + "_" + unicorn_output_file_name	
	pvs_lemma_filename = pvs_lemma_filename.upper()	
	pg = pvs_lemma_generator(pvs_lemma_filename)
	# This sets the name of the inout file for pvs lemma generator to the output file generated by unicorn
	pg.set_name_inputfile(unicorn_output_file_name)
	pg.parse_unicorn_output_file()
	pg.generate_pvs_lemma_file()
	print "Generating " + pvs_lemma_filename  + ".pvs"	
	generate_pvs = tc.test_concrete(bitstring, hexstring)
	print "Generating the test_concrete file for the instruction"
	generate_pvs.extract_inst_class()
	generate_pvs.extract_theory_parameters()
	#inst_imm.view_fields()
	generate_pvs.generate_pvs_code()
