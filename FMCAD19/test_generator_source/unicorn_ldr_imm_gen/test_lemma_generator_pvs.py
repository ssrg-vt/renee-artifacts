#!/usr/bin/env python
# Run the script using python test_lemma_generator_pvs.py <<ASL_inst.xml>> <<ASL_inst_class_name>>
# For example, python test_lemma_generator_pvs.py subs_addsub_shift.xml addsub_shift


import xml.etree.ElementTree as ET
import sys
import json

import re
import os
import os.path as path
import pickle
import master_test as mtest
import test_concrete as tc

class pvs_lemma_generator:

    # Initializes variables for pvs_lemma_generator, input registers, output registers, bitstrings which are randomly generated by the master_test modul
    def __init__(self, pvs_filename):
        self.pvs_lemma_filename = pvs_filename
        # extract the class name from the file name
        self.inst_class = self.pvs_lemma_filename.rsplit("_", 1)[0]
        self.name_inputfile = ""
        self.cur_dir = os.path.abspath('')
        self.unicorn_file_dir = cur_dir + "/unicorn_outputs/"
        self.f = open(self.unicorn_file_dir + pvs_lemma_filename + ".pvs", "w")
        self.input_bitstring = ""
        self.input_hexstring = ""
        self.Rt = ""
        self.Rn = ""
        # self.Rm = ""

        # These store the initial values when running the instruction on Unicorn
        self.Rt_val = []
        self.Rn_val = []
        # self.Rm_val = []
        self.R_NZCV = []
        self.R_PC = []

        # This stores the register number of the output register in Unicorn
        self.R_op = ""
        self.R_op_val = ""

    # This generates the PVS lemma file for the corresponding Unicorn output fi=le for a randomly generated instruction that respects the instruction format
    def generate_pvs_lemma_file(self, post_state, final_address):
        self.f.write(self.pvs_lemma_filename)
        self.f.write(" : THEORY\n")
        self.f.write("\n\n      BEGIN")
        self.f.write("\n\n      IMPORTING rsl@ldr_imm_gen, bitvectors@bv_arith_nat\n")

        self.f.write("\n      X_sts : [ below(32) -> bvec[64] ] = init`X with [( " + self.Rt + " ) := " + self.Rt_val[0] + ",\n\t\t\t\t\t\t\t ( " + self.Rn + " ):= " + self.Rn_val[0] + "] \n")
        self.f.write("\n      Mem_sts: [nat -> bvec[64] ] = init`Mem with [( " + str(final_address) + " ):= bv[64](0b0100000000000000000000000000000000000000000000000000000000000000) ]")
        # self.f.write("\n      p     : s = init with [`X:= X_sts]\n")
        self.f.write("\n\n      p: s = init with [ `X:= X_sts ,`Mem := Mem_sts]")

        self.f.write("\n\n      ldr_1 : Theory = ldr_imm_gen[p]{{ Diag:= bv[32](0b" + self.input_bitstring + ") }}")
        
        # self.f.write("\n      u1 : VAR nat\n")
        self.f.write("\n\n      test_1: lemma ldr_1.post`X( " + self.Rt + " ) = bv[64](0b0100000000000000000000000000000000000000000000000000000000000000)")
        # self.f.write("\n\n      test_2: lemma ldr_1.u = " + final_address + " => ldr_1.post`X( " + self.Rt + " ) = bv[64](0b0100000000000000000000000000000000000000000000000000000000000000)")
        # self.f.write("\n      ldr_1 : lemma ldr_1.u = u1 => \n")
        # self.f.write("                          let X_post = p`X with [ ( " + self.Rt + " ):= " + "p`Mem( u1 ) ] in\n")
        # self.f.write("                                         ldr_1.post`X( " + self.Rt + " ) = " + self.Rt_val[0] + "\n")
        # self.f.write(
        #     "\n                    let p2     = p with [`Mem:= X_post] in \n") #% `NZVC:= " + self.R_NZCV[1] + " , `PC:= " + self.R_PC[1] + "] in\n")
        # self.f.write("\n                                 %ldr_1.post`X( " + self.Rn + " ) = p2`X( " + self.Rn + " ) and\n")
        # self.f.write("\n                                 ldr_1.post`Mem( " + str(post_state) + ", 8, AccType_NORMAL) = p`X( " + self.Rn + " )")
        
        self.f.write("\n\n%|- X_sts_TCC* : PROOF")
        self.f.write("\n%|- Mem_sts_TCC1     : PROOF")
        self.f.write("\n%|- ldr_1_TCC* : PROOF (eval-formula)")
        self.f.write("\n%|- QED")
        # self.f.write("\n%|- test1_TCC1 : PROOF (eval-formula)")
        # self.f.write("\n%|- QED\n")
        self.f.write("\n\n%|- test_1 : PROOF ( ldr_imm_gen )")
        self.f.write("\n%|- QED")
        # self.f.write("\n%|- test_2 : PROOF ( ldr_imm_gen_1 ) QED")

        # self.f.write("\n\n%|- test_* : PROOF (ldr_imm_gen) QED")
        # self.f.write("\n%|- (ldr-imm-gen)")
        # self.f.write("\n%|- QED\n")
        self.f.write("\n\nEND " + self.pvs_lemma_filename)

    def pad_PC_with_zeroes(self, pc):
        bin_pc = bin(int(pc))
        result = bin_pc[2:][::-1].ljust(64, '0')
        return result
    
    # This method sets the filename for the unicorn_output_file which is the input file for this program to generate the pvs test lemma file
    def set_name_inputfile(self, filename):
        self.name_inputfile = filename

    # This method reads from the output file generated by Unicorn for an instruction simulation to extract the parameter values ofr pvs lemma file
    def parse_unicorn_output_file(self):
        try:
            unicorn_file_ptr = open(
                self.unicorn_file_dir + self.name_inputfile, "r")
            print "Opening file " + self.name_inputfile
            for line in unicorn_file_ptr:
                line = line.strip()
                if "=" in line:
                    tokens = line.split("=")
                    if tokens[0] == "input_bitstring":
                        self.input_bitstring = tokens[1]
                    elif tokens[0] == "input_hexstring":
                        self.input_hexstring = tokens[1]
                    elif tokens[0] == "Rt":
                        self.Rt = tokens[1]
                    elif tokens[0] == "Rn":
                        self.Rn = tokens[1]
                    # elif tokens[0] == "Rm":
                        # self.Rm = tokens[1]
                    elif tokens[0] == "Rt_pre":
                        self.Rt_val.append(tokens[1])
                    elif tokens[0] == "Rn_pre":
                        self.Rn_val.append(tokens[1])
                    # elif tokens[0] == "Rm_pre":
                        # self.Rm_val.append(tokens[1])
                    elif tokens[0] == "R_PC_pre":
                        self.R_PC.append(tokens[1])
                    # elif tokens[0] == "R_NZCV_pre":
                        # self.R_NZCV.append(tokens[1])
                    elif tokens[0] == "Rt_post":
                        self.Rt_val.append(tokens[1])
                    # elif tokens[0] == "Rm_post":
                        # self.Rm_val.append(tokens[1])
                    elif tokens[0] == "Rn_post":
                        self.Rn_val.append(tokens[1])
                    elif tokens[0] == "R_PC_post":
                        self.R_PC.append(tokens[1])
                    # elif tokens[0] == "R_NZCV_post":
                        # self.R_NZCV.append(tokens[1])
                    elif tokens[0] == "R_op":
                        self.R_op = tokens[1]
                    elif tokens[0] == "R_op_val":
                        self.R_op_val = tokens[1]
        except IOError:
            print "Error: File does not appear to exist."
            return 0


if __name__ == '__main__':
    cur_dir = os.path.abspath('')
    output_dir = cur_dir + "/unicorn_outputs/"
    # argv[1] is the name of the instruction which needs to be randomly generated and tested
    inst_filename = sys.argv[1]
    
    # Remove the ".xml" from the arg to get the instruction name
    inst_name = inst_filename.replace(".xml", "")
    # Create an object of the inst_generator class
    inst_test_suite = mtest.inst_generator(inst_filename)
    # Extracts the diagram format from ASL for each instruction which is provided in the command line as an argument
    
    # inst_test_suite.extract_fields()

    #hacky fix to extract the fields for the 3rd diagram form load store class
    inst_test_suite.extract_fields_for_diag3()
    # Generates a txt file with field names about the random bitstring generated for a particular ARM inst
    inst_test_suite.generate_validation_file()
    # Extract registers from the previous output
    reg_list = inst_test_suite.get_registers()
    # Fixes the bytestring issue in unicorn for the test genration
    int_list = inst_test_suite.get_bytestr()
    bytecode = bytearray(int_list)
    # Unicorn output file
    unicorn_output_file_name = inst_test_suite.get_hexstring()
    op_fileptr = open(output_dir + unicorn_output_file_name, "w")
    bitstring = inst_test_suite.get_pvs_bitstring()
    hexstring = unicorn_output_file_name
    # Add more info to the file for repeating the test case using the bitstring, hexstring , int_list combination
    op_fileptr.write("input_bitstring=" + bitstring + "\n")
    op_fileptr.write("input_hexstring=" + hexstring + "\n")
    op_fileptr.write("reg_list=" + str(reg_list) + "\n")
    op_fileptr.write("int_list=" + str(int_list) + "\n")
    # Run the instruction
    post_state, final_address = mtest.test_arm64(bytes(bytecode), op_fileptr, reg_list, bitstring)
    # Code for generating the pvs lemma file from the unicorn output file
    pvs_lemma_filename = inst_name + "_" + unicorn_output_file_name
    pvs_lemma_filename = pvs_lemma_filename.upper()
    pg = pvs_lemma_generator(pvs_lemma_filename)
    # This sets the name of the inout file for pvs lemma generator to the output file generated by unicorn
    pg.set_name_inputfile(unicorn_output_file_name)
    pg.parse_unicorn_output_file()
    pg.generate_pvs_lemma_file(post_state, final_address)
    print "Generating " + pvs_lemma_filename + ".pvs"
    generate_pvs = tc.test_concrete(bitstring, hexstring)

    ##############################################################

            ## Decoupling the concrete file generation logic from the test_lemma generator

    #############################################################

    # print "Generating the test_concrete file for the instruction"
    # generate_pvs.extract_inst_class()
    # generate_pvs.extract_theory_parameters()
    # inst_imm.view_fields()
    # generate_pvs.generate_pvs_code()
